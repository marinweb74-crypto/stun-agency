<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STUN Agency</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18.3.1/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/loaders/DRACOLoader.js"></script>

  <script src="https://unpkg.com/lenis@1.1.18/dist/lenis.min.js"></script>
  <!-- GSAP & ScrollTrigger -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

  <script>window.onerror = function (m, s, l, c, e) { if (m === 'Script error.' || !l) return true; if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') { document.body.innerHTML = '<pre style="color:red;padding:40px;font-size:14px">' + m + '\n\nLine: ' + l + '\n' + (e && e.stack || '') + '</pre>'; } }</script>
  <script>
    window.__geoCache = null;
    (function () { try { var r = indexedDB.open('stunGeo', 1); r.onupgradeneeded = function (e) { e.target.result.createObjectStore('g') }; r.onsuccess = function (e) { try { var tx = e.target.result.transaction('g', 'readonly'); var g = tx.objectStore('g').get('c1'); g.onsuccess = function () { window.__geoCache = g.result || null }; g.onerror = function () { } } catch (ex) { } }; r.onerror = function () { } } catch (ex) { } })();
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://prod.spline.design" crossorigin>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="dns-prefetch" href="https://cdn.tailwindcss.com">
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
  <link
    href="https://fonts.googleapis.com/css2?family=Archivo:wght@400;500;700;800&family=Onest:wght@400;500;700&family=IBM+Plex+Mono:wght@500;600&family=Unbounded:wght@600&display=swap"
    rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: { dark: '#0a0a0a', surface: '#111111', accent: '#1a2ffb', light: '#f0f1fa' },
          fontFamily: { sans: ['Onest', 'sans-serif'], mono: ['IBM Plex Mono', 'monospace'], display: ['Archivo', 'sans-serif'] },
          animation: { spotlight: 'spotlight 2s ease .75s 1 forwards' },
          keyframes: { spotlight: { '0%': { opacity: 0, transform: 'translate(-72%, -62%) scale(0.5)' }, '100%': { opacity: 1, transform: 'translate(-50%,-40%) scale(1)' } } }
        }
      }
    }
  </script>
  <style>
    [data-scene-rect],
    [data-scene-rect] canvas {
      cursor: none !important;
    }

    html {
      scroll-behavior: auto;
    }

    body {
      font-family: 'Onest', sans-serif;
      font-weight: 500;
      overflow-x: hidden;
    }

    /* Glitch effect for ANOMALIES */
    .glitch {
      position: relative;
      display: inline-block;
    }

    .glitch::before,
    .glitch::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .glitch::before {
      color: #1a2ffb;
      animation: glitch-1 4s infinite linear;
      clip-path: inset(0 0 0 0);
    }

    .glitch::after {
      color: #ff003c;
      animation: glitch-2 4s infinite linear;
      clip-path: inset(0 0 0 0);
    }

    @keyframes glitch-1 {

      0%,
      88% {
        clip-path: inset(0 100% 0 0);
        opacity: 0;
      }

      89% {
        clip-path: inset(20% 0 50% 0);
        opacity: 0.8;
        transform: translate(-4px, -2px);
      }

      90% {
        clip-path: inset(60% 0 10% 0);
        opacity: 0.8;
        transform: translate(3px, 1px);
      }

      91% {
        clip-path: inset(10% 0 70% 0);
        opacity: 0.8;
        transform: translate(-2px, 3px);
      }

      92% {
        clip-path: inset(40% 0 30% 0);
        opacity: 0.8;
        transform: translate(4px, -1px);
      }

      93%,
      100% {
        clip-path: inset(0 100% 0 0);
        opacity: 0;
        transform: translate(0);
      }
    }

    @keyframes glitch-2 {

      0%,
      90% {
        clip-path: inset(0 100% 0 0);
        opacity: 0;
      }

      91% {
        clip-path: inset(50% 0 20% 0);
        opacity: 0.8;
        transform: translate(4px, 2px);
      }

      92% {
        clip-path: inset(15% 0 55% 0);
        opacity: 0.8;
        transform: translate(-3px, -1px);
      }

      94% {
        clip-path: inset(25% 0 45% 0);
        opacity: 0.8;
        transform: translate(-4px, 1px);
      }

      95%,
      100% {
        clip-path: inset(0 100% 0 0);
        opacity: 0;
        transform: translate(0);
      }
    }

    @keyframes marquee {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-50%);
      }
    }

    @keyframes marquee-reverse {
      0% {
        transform: translateX(-50%);
      }

      100% {
        transform: translateX(0);
      }
    }


    /* Global custom cursor */
    .global-cursor {
      position: fixed;
      pointer-events: none;
      z-index: 99999;
      width: 40px;
      height: 40px;
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.3s cubic-bezier(0.16, 1, 0.3, 1), height 0.3s cubic-bezier(0.16, 1, 0.3, 1), background 0.3s, border-color 0.3s;
      mix-blend-mode: difference;
      background: transparent;
    }

    .global-cursor.hovering {
      width: 80px;
      height: 80px;
      background: #fff;
      border-color: #fff;
    }


    @media (hover: hover) {
      * {
        cursor: none !important;
      }
    }

    @media (hover: none) and (pointer: coarse) {

      *,
      [data-scene-rect],
      [data-scene-rect] canvas {
        cursor: auto !important;
      }

      .global-cursor,
      .cursor-triangle {
        display: none !important;
      }
    }

    .font-display {
      font-family: 'Archivo', sans-serif;
      font-weight: 700;
    }

    .font-mono {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 500;
    }

    /* Triangle cursor */
    .cursor-triangle {
      position: fixed;
      pointer-events: none;
      z-index: 10000;
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 14px solid #f0f1fa;
      mix-blend-mode: difference;
      transform-origin: center center;
      transition: border-bottom-width 0.2s, border-left-width 0.2s, border-right-width 0.2s;
    }

    .cursor-triangle.hover {
      border-left-width: 8px;
      border-right-width: 8px;
      border-bottom-width: 18px;
    }

    /* Preloader */
    @keyframes preloader-spin {
      0% {
        transform: rotate(0deg);
        border-radius: 40% 60% 70% 30% / 40% 50% 60% 50%;
      }

      25% {
        transform: rotate(90deg);
        border-radius: 50% 40% 60% 50% / 60% 40% 50% 60%;
      }

      50% {
        transform: rotate(180deg);
        border-radius: 60% 50% 40% 70% / 50% 60% 40% 50%;
      }

      75% {
        transform: rotate(270deg);
        border-radius: 40% 70% 50% 60% / 70% 50% 60% 40%;
      }

      100% {
        transform: rotate(360deg);
        border-radius: 40% 60% 70% 30% / 40% 50% 60% 50%;
      }
    }

    .preloader-blob {
      width: 60px;
      height: 60px;
      background: #fff;
      animation: preloader-spin 2s ease-in-out infinite;
    }



    /* Service items */
    .service-item {
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }

    .service-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2rem 0;
      cursor: none;
      transition: opacity 0.3s;
    }

    .service-header:hover {
      opacity: 0.7;
    }

    .service-body {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.5s ease, padding 0.5s ease;
    }

    .service-body.open {
      max-height: 300px;
      padding-bottom: 2rem;
    }

    /* Scroll reveal */
    .reveal {
      opacity: 0;
      transform: translateY(40px);
      transition: opacity 0.7s ease-out, transform 0.7s ease-out;
    }

    .reveal.active {
      opacity: 1;
      transform: translateY(0);
    }

    /* Magnetic letter */
    .magnetic-letter {
      display: inline-block;
      transition: transform 0.3s ease-out;
    }

    .magnetic-letter:hover {
      transform: translate(2px, -3px);
    }

    ::selection {
      background: #1a2ffb;
      color: #f0f1fa;
    }


    /* Sound wave animation */
    @keyframes waveShift {
      0% {
        transform: translateX(0);
      }

      100% {
        transform: translateX(-12px);
      }
    }

    @media (max-width: 767px) {

      button,
      a,
      [data-magnetic] {
        min-height: 44px;
        min-width: 44px;
      }
    }

    @media (prefers-reduced-motion: reduce) {

      .glitch::before,
      .glitch::after {
        animation: none;
      }

      .reveal {
        transition: none;
        opacity: 1;
        transform: none;
      }

      /* Отключаем только ненужные эффекты, но оставляем рисование текста */
    }

    .mobile-card-flip {
      transform: rotateY(180deg);
      transition: transform 1.2s cubic-bezier(0.22, 1, 0.36, 1);
    }

    .mobile-card-flip.flipped {
      transform: rotateY(360deg);
    }

    .lets-work-outline {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 12;
      pointer-events: none;
      transform: translate3d(0,0,2px);
      -webkit-transform: translate3d(0,0,2px);
    }

    @keyframes strokeColor {
      0% {
        -webkit-text-stroke-color: #1a2ffb;
      }
      33% {
        -webkit-text-stroke-color: #ff003c;
      }
      66% {
        -webkit-text-stroke-color: #ffbc00;
      }
      100% {
        -webkit-text-stroke-color: #00f3ff;
      }
    }
  </style>
</head>

<body class="bg-[#0a0a0a] text-neutral-900">
  <div id="root"></div>

  <script>
    const {
      useState,
      useRef,
      useEffect,
      useCallback
    } = React;

    // ========== MOBILE DETECTION ==========
    var isMobile = function () {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }();
    var getBreakpoint = function () {
      var w = window.innerWidth;
      if (w < 768) return 'mobile';
      if (w < 1024) return 'tablet';
      return 'desktop';
    };
    function useBreakpoint() {
      var [bp, setBp] = useState(getBreakpoint());
      useEffect(function () {
        var handler = function () {
          setBp(getBreakpoint());
        };
        window.addEventListener('resize', handler);
        return function () {
          window.removeEventListener('resize', handler);
        };
      }, []);
      return bp;
    }

    // ========== GLOBAL AUDIO ==========
    var globalSoundOn = false;
    var globalMusic = new Audio('./music.mp3');
    globalMusic.loop = true;
    globalMusic.volume = 1; // iOS ignores .volume — use GainNode instead
    globalMusic.preload = 'auto';
    // Dual-buffer seamless loop for space track (mobile uses simple loop)
    var spaceA = new Audio('./space.mp3');
    var spaceB = new Audio('./space.mp3');
    spaceA.volume = 1;
    spaceB.volume = 1;
    spaceA.preload = 'auto';
    spaceB.preload = 'auto';
    if (isMobile) {
      spaceA.loop = true; // Simple native loop on mobile — dual-buffer play() fails without gesture
    }
    var spaceCurrent = spaceA;
    var spaceNext = spaceB;
    var spaceDuration = 12; // ~12 seconds
    var spaceCrossfade = 2; // 2 second crossfade
    var spaceStarted = false;
    var musicTargetVol = 0.3;
    var spaceTargetVol = 0;
    var spaceCurrentVol = 0;

    // Web Audio API GainNodes — iOS ignores .volume, only GainNode works
    var musicGain = null;
    var spaceAGain = null;
    var spaceBGain = null;
    var audioGainCtx = null;
    try {
      audioGainCtx = new (window.AudioContext || window.webkitAudioContext)();
      var musicSrc = audioGainCtx.createMediaElementSource(globalMusic);
      musicGain = audioGainCtx.createGain();
      musicGain.gain.value = 0.3;
      musicSrc.connect(musicGain);
      musicGain.connect(audioGainCtx.destination);

      var spaceASrc = audioGainCtx.createMediaElementSource(spaceA);
      spaceAGain = audioGainCtx.createGain();
      spaceAGain.gain.value = 0;
      spaceASrc.connect(spaceAGain);
      spaceAGain.connect(audioGainCtx.destination);

      var spaceBSrc = audioGainCtx.createMediaElementSource(spaceB);
      spaceBGain = audioGainCtx.createGain();
      spaceBGain.gain.value = 0;
      spaceBSrc.connect(spaceBGain);
      spaceBGain.connect(audioGainCtx.destination);
    } catch (e) {
      // Fallback: no Web Audio API — .volume will work on desktop anyway
    }

    // Helper to set volume via GainNode (iOS) or .volume (fallback)
    function setMusicVol(v) {
      if (musicGain) { musicGain.gain.value = v; }
      else { globalMusic.volume = v; }
    }
    function getMusicVol() {
      if (musicGain) return musicGain.gain.value;
      return globalMusic.volume;
    }
    function setSpaceAVol(v) {
      if (spaceAGain) { spaceAGain.gain.value = v; }
      else { spaceA.volume = v; }
    }
    function setSpaceBVol(v) {
      if (spaceBGain) { spaceBGain.gain.value = v; }
      else { spaceB.volume = v; }
    }
    function startSpaceLoop() {
      if (spaceStarted) return;
      spaceStarted = true;
      spaceCurrent.currentTime = 0;
      spaceCurrent.play().catch(function () { });
    }
    function stopSpaceLoop() {
      spaceStarted = false;
      spaceA.pause();
      spaceB.pause();
      spaceA.currentTime = 0;
      spaceB.currentTime = 0;
    }

    // Smooth crossfade tick — only runs when sound is on
    var crossfadeRAF = null;
    function crossfadeTick() {
      if (!globalSoundOn) {
        crossfadeRAF = null;
        return;
      }
      // If music should be playing but is paused — restart it
      if (globalMusic.paused && musicTargetVol > 0) {
        globalMusic.play().catch(function () {});
      }
      var step = 0.01;
      var mv = getMusicVol();
      if (Math.abs(mv - musicTargetVol) > 0.005) {
        setMusicVol(Math.max(0, Math.min(1, mv + (musicTargetVol > mv ? step : -step))));
      }
      // Паузим музыку когда volume дошёл до 0
      if (getMusicVol() < 0.005 && musicTargetVol === 0) {
        globalMusic.pause();
        setMusicVol(0);
      }
      // Smooth space target vol
      var svStep = 0.008;
      if (Math.abs(spaceCurrentVol - spaceTargetVol) > 0.005) {
        spaceCurrentVol += spaceTargetVol > spaceCurrentVol ? svStep : -svStep;
        spaceCurrentVol = Math.max(0, Math.min(1, spaceCurrentVol));
      }

      // Dual buffer crossfade logic (desktop only — mobile uses native loop)
      if (spaceStarted && isMobile) {
        // Mobile: simple volume control via GainNode, native loop handles repeat
        setSpaceAVol(spaceCurrentVol);
      } else if (spaceStarted && spaceCurrent.duration) {
        var timeLeft = spaceCurrent.duration - spaceCurrent.currentTime;
        if (timeLeft < spaceCrossfade && spaceNext.paused) {
          // Start next buffer
          spaceNext.currentTime = 0;
          if (spaceCurrent === spaceA) setSpaceBVol(0);
          else setSpaceAVol(0);
          spaceNext.play().catch(function () { });
        }
        if (timeLeft < spaceCrossfade) {
          var fade = timeLeft / spaceCrossfade; // 1→0
          if (spaceCurrent === spaceA) {
            setSpaceAVol(spaceCurrentVol * fade);
            setSpaceBVol(spaceCurrentVol * (1 - fade));
          } else {
            setSpaceBVol(spaceCurrentVol * fade);
            setSpaceAVol(spaceCurrentVol * (1 - fade));
          }
        } else {
          if (spaceCurrent === spaceA) setSpaceAVol(spaceCurrentVol);
          else setSpaceBVol(spaceCurrentVol);
        }
        // Swap when current ends
        if (spaceCurrent.ended || spaceCurrent.currentTime >= spaceCurrent.duration - 0.05) {
          spaceCurrent.pause();
          var tmp = spaceCurrent;
          spaceCurrent = spaceNext;
          spaceNext = tmp;
        }
      }
      crossfadeRAF = requestAnimationFrame(crossfadeTick);
    }
    function startCrossfade() {
      if (!crossfadeRAF) crossfadeTick();
    }

    // ========== PRELOADER ==========
    function SplashScreen({
      onEnter
    }) {
      var containerRef = useRef(null);
      var btnRef = useRef(null);
      var handleClick = function () {
        globalSoundOn = true;
        if (audioGainCtx && audioGainCtx.state === 'suspended') audioGainCtx.resume();
        startCrossfade();
        globalMusic.play().catch(function () { });
        containerRef.current.style.transition = 'opacity 0.6s ease';
        containerRef.current.style.opacity = '0';
        setTimeout(function () {
          onEnter();
        }, 700);
      };
      return /*#__PURE__*/React.createElement("div", {
        ref: containerRef,
        style: {
          position: 'fixed',
          inset: 0,
          zIndex: 99999,
          background: '#0a0a0a',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '40px'
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          fontFamily: 'Archivo, sans-serif',
          fontSize: 'clamp(32px, 6vw, 56px)',
          fontWeight: 500,
          color: '#fff',
          letterSpacing: '-0.03em',
          textTransform: 'uppercase'
        }
      }, "STUN"), /*#__PURE__*/React.createElement("div", {
        ref: btnRef,
        onClick: handleClick,
        onMouseEnter: function () {
          if (btnRef.current) btnRef.current.style.background = 'rgba(26,47,251,0.15)';
        },
        onMouseLeave: function () {
          if (btnRef.current) btnRef.current.style.background = 'transparent';
        },
        style: {
          width: 'clamp(120px, 16vw, 180px)',
          height: 'clamp(120px, 16vw, 180px)',
          borderRadius: '50%',
          border: '2px solid rgba(255,255,255,0.3)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          transition: 'background 0.3s, transform 0.3s',
          background: 'transparent'
        }
      }, /*#__PURE__*/React.createElement("svg", {
        width: "40%",
        height: "40%",
        viewBox: "0 0 24 24",
        fill: "#fff",
        stroke: "none"
      }, /*#__PURE__*/React.createElement("polygon", {
        points: "6,3 20,12 6,21"
      }))));
    }

    // ========== CUSTOM CURSOR — TRIANGLE (only inside scene rect) ==========
    function CustomCursor() {
      const curRef = useRef(null);
      useEffect(() => {
        if (isMobile) return;
        var el = curRef.current;
        var mx = -100,
          my = -100,
          sx = -100,
          sy = -100;
        var move = function (e) {
          mx = e.clientX;
          my = e.clientY;
        };
        window.addEventListener('mousemove', move, {
          passive: true
        });

        // Hover detection for interactive elements
        var checkHover = function () {
          var hovered = document.querySelectorAll('a:hover, button:hover, [data-magnetic]:hover, h1:hover, h2:hover, h3:hover, p:hover, span:hover, li:hover, label:hover, input:hover, textarea:hover, [data-front]:hover, [data-back]:hover');
          if (hovered.length > 0) {
            el.classList.add('hovering');
          } else {
            el.classList.remove('hovering');
          }
        };
        // Hide cursor when inside SplineSection
        var inSpline = false;
        var splineEl = null;
        var checkSpline = function () {
          if (!splineEl) splineEl = document.getElementById('spline-scene');
          if (splineEl) {
            var r = splineEl.getBoundingClientRect();
            inSpline = mx >= r.left && mx <= r.right && my >= r.top && my <= r.bottom;
          }
        };
        var aid;
        var tick = function () {
          sx += (mx - sx) * 0.15;
          sy += (my - sy) * 0.15;
          el.style.left = sx + 'px';
          el.style.top = sy + 'px';
          checkSpline();
          if (inSpline) {
            el.style.opacity = '0';
          } else {
            el.style.opacity = '';
            checkHover();
          }
          aid = requestAnimationFrame(tick);
        };
        tick();
        return function () {
          cancelAnimationFrame(aid);
          window.removeEventListener('mousemove', move);
        };
      }, []);
      if (isMobile) return null;
      return /*#__PURE__*/React.createElement("div", {
        ref: curRef,
        className: "global-cursor"
      });
    }

    // ========== MAGNETIC BUTTON WRAPPER ==========
    function MagneticWrap({
      children,
      strength
    }) {
      var ref = useRef(null);
      var s = strength || 0.35;
      var onMove = function (e) {
        if (isMobile) return;
        var el = ref.current;
        if (!el) return;
        var r = el.getBoundingClientRect();
        var cx = r.left + r.width / 2;
        var cy = r.top + r.height / 2;
        var dx = e.clientX - cx;
        var dy = e.clientY - cy;
        el.style.transform = 'translate(' + dx * s + 'px, ' + dy * s + 'px)';
      };
      var onLeave = function () {
        if (ref.current) ref.current.style.transform = 'translate(0,0)';
      };
      return React.createElement('div', {
        ref: ref,
        'data-magnetic': true,
        onMouseMove: onMove,
        onMouseLeave: onLeave,
        style: {
          transition: 'transform 0.3s cubic-bezier(0.16,1,0.3,1)',
          display: 'inline-flex'
        }
      }, children);
    }

    // ========== FLUID GLASS TRAIL (inside rectangle only) ==========

    // ========== DEVICE CAPABILITY DETECTION ==========
    var _deviceCap = null;
    function detectDeviceCapability() {
      if (_deviceCap) return _deviceCap;
      var tier = 'medium';
      try {
        var c = document.createElement('canvas');
        var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
        if (gl) {
          var dbg = gl.getExtension('WEBGL_debug_renderer_info');
          if (dbg) {
            var gpu = gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL).toLowerCase();
            // High-end GPUs
            if (/rtx|rx\s?(6|7)\d{3}|radeon\s?pro|m[1-4]\s?(pro|max|ultra)|apple\s?gpu/i.test(gpu)) {
              tier = 'high';
            }
            // Low-end / integrated
            else if (/intel|hd\s?graphics|uhd\s?graphics|mali-4|mali-t[67]|adreno\s?(3|4|5)\d{2}|powervr|sgx/i.test(gpu)) {
              tier = 'low';
            }
          }
          c.width = 1; c.height = 1;
          var ext = gl.getExtension('WEBGL_lose_context');
          if (ext) ext.loseContext();
        }
      } catch (e) { }
      _deviceCap = {
        tier: tier,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        postProcessing: tier !== 'low'
      };
      return _deviceCap;
    }

    var _cachedEnvRT = null;
    var _splineVisible = false;
    var _onSplineChange = null;

    // ========== SINGLE SCROLL DISPATCHER ==========
    var _scrollListeners = [];
    var _lastScrollDispatch = 0;
    function _onGlobalScroll() {
      var now = performance.now();
      if (now - _lastScrollDispatch < 16) return;
      _lastScrollDispatch = now;
      for (var i = 0; i < _scrollListeners.length; i++) {
        _scrollListeners[i]();
      }
    }
    window.addEventListener('scroll', _onGlobalScroll, { passive: true });
    function addScrollListener(fn) {
      _scrollListeners.push(fn);
      return function () {
        var idx = _scrollListeners.indexOf(fn);
        if (idx >= 0) _scrollListeners.splice(idx, 1);
      };
    }

    // ========== SPLINE PREFETCH AT 40% SCROLL ==========
    var _splinePrefetched = false;
    addScrollListener(function () {
      if (_splinePrefetched) return;
      var docH = document.documentElement.scrollHeight - window.innerHeight;
      if (docH > 0 && window.scrollY / docH > 0.4) {
        _splinePrefetched = true;
        var link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = 'https://prod.spline.design/kZDDjO5HuC9GJUM2/scene.splinecode';
        link.as = 'fetch';
        link.crossOrigin = 'anonymous';
        document.head.appendChild(link);
      }
    });

    // ========== 3D STELLATED SCENE ==========
    function StellatedScene() {
      var bp = useBreakpoint();
      var isMobile = bp === 'mobile';
      const containerRef = useRef(null);
      const canvasRef = useRef(null);
      useEffect(function () {
        var container = containerRef.current;
        var canvas = canvasRef.current;
        if (!container || !canvas) return;
        var w = container.clientWidth,
          h = container.clientHeight;
        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        var fov = 45,
          fov2 = fov * Math.PI / 360;
        var camera = new THREE.PerspectiveCamera(fov, w / h, 0.1, 500);
        camera.position.set(0, 0, 80);
        var devCap = detectDeviceCapability();
        var renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          antialias: true,
          alpha: false,
          powerPreference: 'high-performance',
          stencil: false,
          preserveDrawingBuffer: false
        });
        renderer.setSize(w, h);
        renderer.setPixelRatio(devCap.pixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        // Post-processing (disabled on mobile and low-end devices)
        var usePostProcessing = devCap.tier !== 'low';
        var dpr, rtScale, rt, postScene, postCamera, postMat, postQuad, sMx, sMy, sVel;
        if (usePostProcessing) {
          dpr = devCap.pixelRatio;
          rtScale = 0.75;
          rt = new THREE.WebGLRenderTarget(w * dpr * rtScale, h * dpr * rtScale, {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            encoding: THREE.sRGBEncoding,
            samples: 0
          });
          postScene = new THREE.Scene();
          postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
          postMat = new THREE.ShaderMaterial({
            uniforms: {
              uTexture: {
                value: rt.texture
              },
              uMouse: {
                value: new THREE.Vector2(0.5, 0.5)
              },
              uVelocity: {
                value: 0.0
              },
              uRadius: {
                value: 0.18
              },
              uTime: {
                value: 0.0
              },
              uResolution: {
                value: new THREE.Vector2(w * dpr * rtScale, h * dpr * rtScale)
              }
            },
            vertexShader: 'varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }',
            fragmentShader: [
              'uniform sampler2D uTexture;',
              'uniform vec2 uMouse;',
              'uniform float uVelocity;',
              'uniform float uRadius;',
              'uniform float uTime;',
              'uniform vec2 uResolution;',
              'varying vec2 vUv;',
              'vec4 fxaa(sampler2D tex, vec2 uv, vec2 rcpRes) {',
              '  vec3 rgbNW = texture2D(tex, uv + vec2(-1.0, -1.0) * rcpRes).rgb;',
              '  vec3 rgbNE = texture2D(tex, uv + vec2( 1.0, -1.0) * rcpRes).rgb;',
              '  vec3 rgbSW = texture2D(tex, uv + vec2(-1.0,  1.0) * rcpRes).rgb;',
              '  vec3 rgbSE = texture2D(tex, uv + vec2( 1.0,  1.0) * rcpRes).rgb;',
              '  vec4 rgbM  = texture2D(tex, uv);',
              '  vec3 luma = vec3(0.299, 0.587, 0.114);',
              '  float lumaNW = dot(rgbNW, luma);',
              '  float lumaNE = dot(rgbNE, luma);',
              '  float lumaSW = dot(rgbSW, luma);',
              '  float lumaSE = dot(rgbSE, luma);',
              '  float lumaM  = dot(rgbM.rgb, luma);',
              '  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));',
              '  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));',
              '  vec2 dir = vec2(-(lumaNW + lumaNE) + (lumaSW + lumaSE), (lumaNW + lumaSW) - (lumaNE + lumaSE));',
              '  float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.03125, 1.0/128.0);',
              '  float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);',
              '  dir = clamp(dir * rcpDirMin, vec2(-8.0), vec2(8.0)) * rcpRes;',
              '  vec4 rgbA = 0.5 * (texture2D(tex, uv + dir * (1.0/3.0 - 0.5)) + texture2D(tex, uv + dir * (2.0/3.0 - 0.5)));',
              '  vec4 rgbB = rgbA * 0.5 + 0.25 * (texture2D(tex, uv + dir * -0.5) + texture2D(tex, uv + dir * 0.5));',
              '  float lumaB = dot(rgbB.rgb, luma);',
              '  return (lumaB < lumaMin || lumaB > lumaMax) ? rgbA : rgbB;',
              '}',
              'void main() {',
              '  vec2 uv = vUv;',
              '  vec2 toMouse = uv - uMouse;',
              '  float dist = length(toMouse);',
              '  float t = smoothstep(uRadius, 0.0, dist);',
              '  float strength = t * (0.15 + uVelocity * 0.6);',
              '  vec2 dir2 = dist > 0.001 ? normalize(toMouse) : vec2(0.0);',
              '  vec2 distorted = uv + dir2 * strength * 0.06;',
              '  gl_FragColor = fxaa(uTexture, distorted, 1.0 / uResolution);',
              '}'
            ].join('\n')
          });
          postQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), postMat);
          postScene.add(postQuad);
          sMx = 0.5;
          sMy = 0.5;
          sVel = 0.0;
        }

        // Dramatic single-source lighting — deep contrast, glossy reflections
        scene.add(new THREE.AmbientLight(0x182040, 0.4));
        var keyL = new THREE.DirectionalLight(0xfff5e8, 2.4);
        keyL.position.set(-50, 60, 40);
        scene.add(keyL);

        // Minimal env map for glossy reflections (cached globally)
        if (!_cachedEnvRT) {
          var pmremGen = new THREE.PMREMGenerator(renderer);
          var envScene = new THREE.Scene();
          envScene.background = new THREE.Color(0x0a0a12);
          var eL1 = new THREE.PointLight(0xfff0dd, 2.5, 100);
          eL1.position.set(-25, 20, 15);
          envScene.add(eL1);
          _cachedEnvRT = pmremGen.fromScene(envScene);
          pmremGen.dispose();
        }
        scene.environment = _cachedEnvRT.texture;

        // Cross maker — clean smooth cross
        var makeCross = function (sz, color) {
          var rr = sz * 0.12,
            halfLen = sz * 0.35;
          var kk = rr * 0.4,
            kk6 = kk / 6;
          var rnd = rr * 0.2;
          var cylY = function (x, y, z, h, r) {
            var qr = Math.sqrt(x * x + z * z) - r + rnd;
            var qy = (y < 0 ? -y : y) - h + rnd;
            var mr = qr > 0 ? qr : 0,
              my = qy > 0 ? qy : 0;
            return Math.min(Math.max(qr, qy), 0) + Math.sqrt(mr * mr + my * my) - rnd;
          };
          var cylX = function (x, y, z, h, r) {
            var qr = Math.sqrt(y * y + z * z) - r + rnd;
            var qx = (x < 0 ? -x : x) - h + rnd;
            var mr = qr > 0 ? qr : 0,
              mx = qx > 0 ? qx : 0;
            return Math.min(Math.max(qr, qx), 0) + Math.sqrt(mr * mr + mx * mx) - rnd;
          };
          var cylZ = function (x, y, z, h, r) {
            var qr = Math.sqrt(x * x + y * y) - r + rnd;
            var qz = (z < 0 ? -z : z) - h + rnd;
            var mr = qr > 0 ? qr : 0,
              mz = qz > 0 ? qz : 0;
            return Math.min(Math.max(qr, qz), 0) + Math.sqrt(mr * mr + mz * mz) - rnd;
          };
          var holeR = rr * 0.289,
            holeDep = rr * 0.575,
            hRnd = rr * 0.06;
          var sdf = function (x, y, z) {
            var dY = cylY(x, y, z, halfLen, rr);
            var dX = cylX(x, y, z, halfLen, rr);
            var dZ = cylZ(x, y, z, halfLen, rr);
            var ab = dY - dX;
            if (ab < 0) ab = -ab;
            var h = (kk - ab) / kk;
            if (h < 0) h = 0;
            var m = (dY < dX ? dY : dX) - h * h * h * kk6;
            ab = m - dZ;
            if (ab < 0) ab = -ab;
            h = (kk - ab) / kk;
            if (h < 0) h = 0;
            var d = (m < dZ ? m : dZ) - h * h * h * kk6;
            var qr, qa, ax, mr, ma, s;
            qr = Math.sqrt(y * y + z * z) - holeR + hRnd;
            mr = qr > 0 ? qr : 0;
            ax = x - halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            ax = x + halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            qr = Math.sqrt(x * x + z * z) - holeR + hRnd;
            mr = qr > 0 ? qr : 0;
            ax = y - halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            ax = y + halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            qr = Math.sqrt(x * x + y * y) - holeR + hRnd;
            mr = qr > 0 ? qr : 0;
            ax = z - halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            ax = z + halfLen;
            if (ax < 0) ax = -ax;
            qa = ax - holeDep + hRnd;
            ma = qa > 0 ? qa : 0;
            s = Math.min(Math.max(qr, qa), 0) + Math.sqrt(mr * mr + ma * ma) - hRnd;
            if (-s > d) d = -s;
            return d;
          };
          var eps = rr * 0.035;
          var sdfN = function (x, y, z) {
            var gx = sdf(x + eps, y, z) - sdf(x - eps, y, z);
            var gy = sdf(x, y + eps, z) - sdf(x, y - eps, z);
            var gz = sdf(x, y, z + eps) - sdf(x, y, z - eps);
            var l = Math.sqrt(gx * gx + gy * gy + gz * gz);
            if (l > 1e-6) {
              gx /= l;
              gy /= l;
              gz /= l;
            }
            return [gx, gy, gz];
          };
          var R = isMobile ? 200 : 280,
            ext = halfLen + rr * 1.5,
            st = 2 * ext / R,
            SS = R + 1;
          var grid = new Float32Array(SS * SS * SS);
          for (var iz = 0; iz < SS; iz++) for (var iy = 0; iy < SS; iy++) for (var ix = 0; ix < SS; ix++) grid[ix + SS * (iy + SS * iz)] = sdf(-ext + ix * st, -ext + iy * st, -ext + iz * st);
          var VB = [],
            NB = [];
          var gv = function (a, b, c) {
            return grid[a + SS * (b + SS * c)];
          };
          var gp = function (a, b, c) {
            return [-ext + a * st, -ext + b * st, -ext + c * st];
          };
          var lp = function (p0, p1, v0, v1) {
            var t = v0 / (v0 - v1);
            return [p0[0] + (p1[0] - p0[0]) * t, p0[1] + (p1[1] - p0[1]) * t, p0[2] + (p1[2] - p0[2]) * t];
          };
          var emT = function (a, b, c) {
            var na = sdfN(a[0], a[1], a[2]),
              nb = sdfN(b[0], b[1], b[2]),
              nc = sdfN(c[0], c[1], c[2]);
            var e1x = b[0] - a[0],
              e1y = b[1] - a[1],
              e1z = b[2] - a[2];
            var e2x = c[0] - a[0],
              e2y = c[1] - a[1],
              e2z = c[2] - a[2];
            var fx = e1y * e2z - e1z * e2y,
              fy = e1z * e2x - e1x * e2z,
              fz = e1x * e2y - e1y * e2x;
            if (fx * na[0] + fy * na[1] + fz * na[2] < 0) {
              VB.push(a[0], a[1], a[2], c[0], c[1], c[2], b[0], b[1], b[2]);
              NB.push(na[0], na[1], na[2], nc[0], nc[1], nc[2], nb[0], nb[1], nb[2]);
            } else {
              VB.push(a[0], a[1], a[2], b[0], b[1], b[2], c[0], c[1], c[2]);
              NB.push(na[0], na[1], na[2], nb[0], nb[1], nb[2], nc[0], nc[1], nc[2]);
            }
          };
          var doT = function (ps, vs) {
            var ins = [],
              outs = [];
            for (var i = 0; i < 4; i++) {
              if (vs[i] < 0) ins.push(i); else outs.push(i);
            }
            var n = ins.length;
            if (n === 0 || n === 4) return;
            if (n === 1) {
              var a = ins[0];
              emT(lp(ps[a], ps[outs[0]], vs[a], vs[outs[0]]), lp(ps[a], ps[outs[1]], vs[a], vs[outs[1]]), lp(ps[a], ps[outs[2]], vs[a], vs[outs[2]]));
            } else if (n === 3) {
              var a = outs[0];
              emT(lp(ps[a], ps[ins[0]], vs[a], vs[ins[0]]), lp(ps[a], ps[ins[1]], vs[a], vs[ins[1]]), lp(ps[a], ps[ins[2]], vs[a], vs[ins[2]]));
            } else {
              var a = ins[0],
                b = ins[1],
                c = outs[0],
                d = outs[1];
              var ac = lp(ps[a], ps[c], vs[a], vs[c]),
                ad = lp(ps[a], ps[d], vs[a], vs[d]);
              var bc = lp(ps[b], ps[c], vs[b], vs[c]),
                bd = lp(ps[b], ps[d], vs[b], vs[d]);
              emT(ac, ad, bc);
              emT(ad, bd, bc);
            }
          };
          var TI = [[0, 7, 1, 3], [0, 7, 3, 2], [0, 7, 2, 6], [0, 7, 6, 4], [0, 7, 4, 5], [0, 7, 5, 1]];
          for (var iz = 0; iz < R; iz++) for (var iy = 0; iy < R; iy++) for (var ix = 0; ix < R; ix++) {
            var cv = [gv(ix, iy, iz), gv(ix + 1, iy, iz), gv(ix, iy + 1, iz), gv(ix + 1, iy + 1, iz), gv(ix, iy, iz + 1), gv(ix + 1, iy, iz + 1), gv(ix, iy + 1, iz + 1), gv(ix + 1, iy + 1, iz + 1)];
            var hasN = false,
              hasP = false;
            for (var q = 0; q < 8; q++) {
              if (cv[q] < 0) hasN = true; else hasP = true;
            }
            if (!hasN || !hasP) continue;
            var cp = [gp(ix, iy, iz), gp(ix + 1, iy, iz), gp(ix, iy + 1, iz), gp(ix + 1, iy + 1, iz), gp(ix, iy, iz + 1), gp(ix + 1, iy, iz + 1), gp(ix, iy + 1, iz + 1), gp(ix + 1, iy + 1, iz + 1)];
            for (var t = 0; t < 6; t++) {
              var ti = TI[t];
              doT([cp[ti[0]], cp[ti[1]], cp[ti[2]], cp[ti[3]]], [cv[ti[0]], cv[ti[1]], cv[ti[2]], cv[ti[3]]]);
            }
          }

          // Deduplicate vertices & average normals
          var qS = Math.round(5 / st);
          var vMap = {},
            uV = [],
            uN = [],
            idxArr = [];
          for (var vi = 0; vi < VB.length; vi += 3) {
            var px = VB[vi],
              py = VB[vi + 1],
              pz = VB[vi + 2];
            var key = Math.round(px * qS) + ',' + Math.round(py * qS) + ',' + Math.round(pz * qS);
            if (vMap[key] === undefined) {
              vMap[key] = uV.length / 3;
              uV.push(px, py, pz);
              uN.push(NB[vi], NB[vi + 1], NB[vi + 2]);
            } else {
              var mi = vMap[key];
              uN[mi * 3] += NB[vi];
              uN[mi * 3 + 1] += NB[vi + 1];
              uN[mi * 3 + 2] += NB[vi + 2];
            }
            idxArr.push(vMap[key]);
          }
          for (var ni = 0; ni < uN.length; ni += 3) {
            var nx = uN[ni],
              ny = uN[ni + 1],
              nz = uN[ni + 2];
            var l = Math.sqrt(nx * nx + ny * ny + nz * nz);
            if (l > 1e-6) {
              uN[ni] /= l;
              uN[ni + 1] /= l;
              uN[ni + 2] /= l;
            }
          }
          var geo = new THREE.BufferGeometry();
          geo.setIndex(idxArr);
          geo.setAttribute('position', new THREE.Float32BufferAttribute(uV, 3));
          geo.setAttribute('normal', new THREE.Float32BufferAttribute(uN, 3));
          geo.computeBoundingSphere();
          var mat = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.35,
            roughness: 0.15
          });
          return new THREE.Mesh(geo, mat);
        };

        // Viewport dimensions in world coords
        var VH = 2 * Math.tan(fov2) * 80;
        var VW = VH * (w / h);
        var BX = VW / 2,
          BY = VH / 2,
          BZ = 25;
        var pxToWorld = VH / h;

        // Palette: black, deep blue, dark saturated yellow-orange
        var palette = [0x0a0a12, 0x1a2ffb, 0x1a2ffb, 0x0a0a12, 0x0a0a12, 0x1a2ffb, 0x1a2ffb, 0x0a0a12, 0x0a0a12, 0x1a2ffb, 0x1a2ffb, 0x0a0a12];

        // Spawn 11 bodies in grid
        var N = isMobile ? 6 : 12;
        var B = [];
        var cols = isMobile ? 3 : 4,
          rows = isMobile ? 2 : 3;
        var cellW = VW * 0.92 / cols;
        var cellH = VH * 0.92 / rows;
        var startX = -VW * 0.46;
        var startY = -VH * 0.46;
        var sharedGeo = null;
        if (window.__geoCache) {
          sharedGeo = new THREE.BufferGeometry();
          sharedGeo.setIndex(new THREE.BufferAttribute(new Uint32Array(window.__geoCache.idx), 1));
          sharedGeo.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(window.__geoCache.pos), 3));
          sharedGeo.setAttribute('normal', new THREE.Float32BufferAttribute(new Float32Array(window.__geoCache.nrm), 3));
          sharedGeo.computeBoundingSphere();
        } else {
          var refMesh = makeCross(54, palette[0]);
          sharedGeo = refMesh.geometry;
          try {
            var cPos = new Float32Array(sharedGeo.attributes.position.array);
            var cNrm = new Float32Array(sharedGeo.attributes.normal.array);
            var cIdx = sharedGeo.index ? new Uint32Array(sharedGeo.index.array) : new Uint32Array(0);
            var dbR = indexedDB.open('stunGeo', 1);
            dbR.onupgradeneeded = function (e) { e.target.result.createObjectStore('g'); };
            dbR.onsuccess = function (e) {
              var tx = e.target.result.transaction('g', 'readwrite');
              tx.objectStore('g').put({ pos: cPos, nrm: cNrm, idx: cIdx }, 'c1');
            };
          } catch (ex) { }
        }
        var sz = 54;
        var matCache = {};
        for (var i = 0; i < N; i++) {
          var colHex = palette[i % palette.length];
          if (!matCache[colHex]) {
            matCache[colHex] = new THREE.MeshStandardMaterial({
              color: colHex,
              metalness: 0.35,
              roughness: 0.15
            });
          }
          var mesh = new THREE.Mesh(sharedGeo, matCache[colHex]);
          scene.add(mesh);
          var col = i % cols,
            row = Math.floor(i / cols);
          var bx = startX + col * cellW + cellW * 0.5 + (Math.random() - 0.5) * cellW * 0.35;
          var by = startY + row * cellH + cellH * 0.5 + (Math.random() - 0.5) * cellH * 0.35;
          B.push({
            m: mesh,
            sz: sz,
            rad: sz * 0.4,
            ox: bx,
            oy: by,
            dx: 0,
            dy: 0,
            dz: 0,
            dvx: 0,
            dvy: 0,
            dvz: 0,
            drx: 0,
            dry: 0,
            drz: 0,
            ph: Math.random() * Math.PI * 2
          });
          mesh.position.set(bx, by, -2 + Math.random() * 4);
        }

        // Pre-compile shaders to avoid first-frame stutter
        renderer.compile(scene, camera);

        // Mouse tracking
        var mx = 0,
          my = 0,
          pmx = 0,
          pmy = 0,
          mIn = false;
        var mdx = 0,
          mdy = 0,
          mspd = 0;
        var projVec = new THREE.Vector3();

        // Base position — pure math, ZERO jitter, pre-allocated arrays to avoid GC
        var _bp = [0, 0, 0], _br = [0, 0, 0];
        var basePos = function (b, t) {
          var fi = b.ph * 3.7;
          _bp[0] = Math.sin(t * 0.3 + fi) * BX * 0.55 + Math.sin(t * 0.17 + fi * 2.3) * BX * 0.25;
          _bp[1] = Math.cos(t * 0.25 + fi * 1.4) * BY * 0.5 + Math.cos(t * 0.13 + fi * 0.8) * BY * 0.2;
          _bp[2] = Math.sin(t * 0.2 + fi * 1.7) * 12;
          return _bp;
        };
        var baseRot = function (b, t) {
          _br[0] = b.ph + Math.sin(t * 0.15 + b.ph) * 0.5;
          _br[1] = b.ph * 2 + Math.cos(t * 0.12 + b.ph * 1.3) * 0.5;
          _br[2] = Math.sin(t * 0.09 + b.ph * 0.7) * 0.3;
          return _br;
        };
        var onMove = function (e) {
          var rect = container.getBoundingClientRect();
          mx = e.clientX - rect.left;
          my = e.clientY - rect.top;
        };
        var onEnter = function () {
          mIn = true;
        };
        var onLeave = function () {
          mIn = false;
        };
        container.addEventListener('mousemove', onMove);
        container.addEventListener('mouseenter', onEnter);
        container.addEventListener('mouseleave', onLeave);
        var onTouch = function (e) {
          if (e.touches.length > 0) {
            var rect = container.getBoundingClientRect();
            mx = e.touches[0].clientX - rect.left;
            my = e.touches[0].clientY - rect.top;
            mIn = true;
          }
        };
        var onTouchEnd = function () {
          mIn = false;
        };
        container.addEventListener('touchmove', onTouch, {
          passive: true
        });
        container.addEventListener('touchstart', onTouch, {
          passive: true
        });
        container.addEventListener('touchend', onTouchEnd);

        // Pre-allocate position array (avoid GC every frame)
        var FP = [];
        for (var fpi = 0; fpi < N; fpi++) FP.push([0, 0, 0]);
        var time = 0,
          aid,
          frameCount = 0;
        var sceneVisible = true;
        var visObs = new IntersectionObserver(function (entries) {
          sceneVisible = entries[0].isIntersecting;
          if (sceneVisible && !_splineVisible && !aid) tick();
        }, {
          threshold: 0
        });
        visObs.observe(container);
        _onSplineChange = function () {
          if (!_splineVisible && sceneVisible && !aid) tick();
        };
        var tick = function () {
          if (!sceneVisible || _splineVisible) {
            aid = null;
            return;
          }
          frameCount++;
          time = performance.now() * 0.001;

          mdx = mx - pmx;
          mdy = my - pmy;
          mspd = Math.sqrt(mdx * mdx + mdy * mdy);

          // Compute final positions (base + displacement)
          for (var i = 0; i < N; i++) {
            var b = B[i];
            var bp = basePos(b, time);
            FP[i][0] = bp[0] + b.dx;
            FP[i][1] = bp[1] + b.dy;
            FP[i][2] = bp[2] + b.dz;
          }
          for (var i = 0; i < N; i++) {
            var b = B[i];
            var fx = FP[i][0],
              fy = FP[i][1],
              fz = FP[i][2];

            // Cursor — full physics push (affects displacement)
            if (mIn) {
              projVec.set(fx, fy, fz).project(camera);
              var sx = (projVec.x * 0.5 + 0.5) * w;
              var sy = (-projVec.y * 0.5 + 0.5) * h;
              var ddx = sx - mx,
                ddy = sy - my;
              var dist = Math.sqrt(ddx * ddx + ddy * ddy);
              if (dist < 180 && dist > 1) {
                var t2 = 1 - dist / 180;
                t2 = t2 * t2 * t2;
                if (mspd > 1.5) {
                  var sw = t2 * mspd * 1.2 * pxToWorld;
                  b.dvx += mdx / mspd * sw;
                  b.dvy -= mdy / mspd * sw;
                }
                var rp = t2 * 3 * pxToWorld;
                b.dvx += ddx / dist * rp;
                b.dvy -= ddy / dist * rp;
                b.dvz += (Math.random() - 0.5) * rp * 0.8;
                b.drx += t2 * 0.06;
                b.dry += t2 * 0.04;
              }
            }

            // Integrate displacement
            b.dx += b.dvx;
            b.dy += b.dvy;
            b.dz += b.dvz;

            // Decay displacement + velocity (returns to base = zero jitter)
            b.dvx *= 0.92;
            b.dvy *= 0.92;
            b.dvz *= 0.90;
            b.dx *= 0.97;
            b.dy *= 0.97;
            b.dz *= 0.97;
            b.drx *= 0.95;
            b.dry *= 0.95;
            b.drz *= 0.95;
          }

          // Collision on final positions — pushes displacement
          for (var ci = 0; ci < N; ci++) {
            for (var cj = ci + 1; cj < N; cj++) {
              var a = B[ci],
                bb = B[cj];
              var collR = (a.sz + bb.sz) * 0.5;
              // Early exit: cheap axis-aligned check before sqrt
              var ax = FP[ci][0],
                ay = FP[ci][1],
                az = FP[ci][2];
              var bx2 = FP[cj][0],
                by2 = FP[cj][1],
                bz2 = FP[cj][2];
              var ddx2 = ax - bx2,
                ddy2 = ay - by2,
                ddz2 = az - bz2;
              if (ddx2 > collR || ddx2 < -collR || ddy2 > collR || ddy2 < -collR) continue;
              var d = Math.sqrt(ddx2 * ddx2 + ddy2 * ddy2 + ddz2 * ddz2);
              if (d < collR && d > 0.01) {
                var nx = ddx2 / d,
                  ny = ddy2 / d,
                  nz = ddz2 / d;
                var overlap = 1 - d / collR;
                var push = overlap * overlap * 0.2;
                a.dvx += nx * push;
                a.dvy += ny * push;
                a.dvz += nz * push;
                bb.dvx -= nx * push;
                bb.dvy -= ny * push;
                bb.dvz -= nz * push;
                var rvn = (a.dvx - bb.dvx) * nx + (a.dvy - bb.dvy) * ny + (a.dvz - bb.dvz) * nz;
                if (rvn < 0) {
                  a.dvx -= nx * rvn * 0.5;
                  a.dvy -= ny * rvn * 0.5;
                  a.dvz -= nz * rvn * 0.5;
                  bb.dvx += nx * rvn * 0.5;
                  bb.dvy += ny * rvn * 0.5;
                  bb.dvz += nz * rvn * 0.5;
                }
                if (d < collR * 0.7) {
                  var fix = (collR * 0.7 - d) * 0.2;
                  a.dx += nx * fix;
                  a.dy += ny * fix;
                  a.dz += nz * fix;
                  bb.dx -= nx * fix;
                  bb.dy -= ny * fix;
                  bb.dz -= nz * fix;
                }
              }
            }
          }

          // Apply final positions & rotations
          for (var i = 0; i < N; i++) {
            var b = B[i];
            var bp = basePos(b, time);
            var br = baseRot(b, time);
            b.m.position.set(bp[0] + b.dx, bp[1] + b.dy, bp[2] + b.dz);
            b.m.rotation.set(br[0] + b.drx, br[1] + b.dry, br[2] + b.drz);
          }
          pmx = mx;
          pmy = my;
          if (usePostProcessing) {
            // Update refraction shader
            if (mIn) {
              sMx += (mx / w - sMx) * 0.12;
              sMy += (1.0 - my / h - sMy) * 0.12;
              sVel += (Math.min(mspd / 40, 1.0) - sVel) * 0.08;
            } else {
              sVel *= 0.92;
            }
            postMat.uniforms.uMouse.value.set(sMx, sMy);
            postMat.uniforms.uVelocity.value = sVel;
            postMat.uniforms.uTime.value = time;
            renderer.setRenderTarget(rt);
            renderer.render(scene, camera);
            renderer.setRenderTarget(null);
            renderer.render(postScene, postCamera);
          } else {
            renderer.render(scene, camera);
          }
          aid = requestAnimationFrame(tick);
        };
        tick();
        var onResize = function () {
          w = container.clientWidth;
          h = container.clientHeight;
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);
          if (usePostProcessing) {
            var d = devCap.pixelRatio;
            rt.setSize(w * d * rtScale, h * d * rtScale);
            postMat.uniforms.uResolution.value.set(w * d * rtScale, h * d * rtScale);
          }
          VH = 2 * Math.tan(fov2) * 80;
          VW = VH * (w / h);
          BX = VW / 2;
          BY = VH / 2;
          pxToWorld = VH / h;
        };
        window.addEventListener('resize', onResize);
        return function () {
          cancelAnimationFrame(aid);
          visObs.disconnect();
          container.removeEventListener('mousemove', onMove);
          container.removeEventListener('mouseenter', onEnter);
          container.removeEventListener('mouseleave', onLeave);
          container.removeEventListener('touchmove', onTouch);
          container.removeEventListener('touchstart', onTouch);
          container.removeEventListener('touchend', onTouchEnd);
          window.removeEventListener('resize', onResize);
          if (usePostProcessing) {
            rt.dispose();
            postMat.dispose();
          }
          scene.traverse(function (o) {
            if (o.geometry) o.geometry.dispose();
            if (o.material) {
              if (Array.isArray(o.material)) o.material.forEach(function (m) {
                m.dispose();
              }); else o.material.dispose();
            }
          });
          renderer.dispose();
        };
      }, []);
      return /*#__PURE__*/React.createElement("div", {
        ref: containerRef,
        "data-scene-rect": true,
        style: {
          width: '100%',
          height: '100%',
          borderRadius: '20px',
          overflow: 'hidden',
          position: 'relative'
        }
      }, /*#__PURE__*/React.createElement("canvas", {
        ref: canvasRef,
        style: {
          display: 'block'
        }
      }));
    }

    // ========== NAVIGATION ==========
    function Navigation() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      const [scrolled, setScrolled] = useState(false);
      const [menuOpen, setMenuOpen] = useState(false);
      const [soundOn, setSoundOn] = useState(true);
      const [hideNav, setHideNav] = useState(false);
      const logoRef = useRef(null);
      const audioStarted = useRef(false);
      useEffect(() => {
        var aboutEl = null;
        var darkDiv = null;
        var logo = logoRef.current;
        var navH = isMob ? 40 : 80;
        var cacheTimer = setTimeout(function () {
          aboutEl = document.getElementById('about');
          if (aboutEl) darkDiv = aboutEl.parentElement;
        }, 500);

        // Debug panel for mobile audio diagnostics
        var dbgPanel = null;
        if (isMob) {
          dbgPanel = document.createElement('div');
          dbgPanel.id = 'audio-dbg';
          dbgPanel.style.cssText = 'position:fixed;bottom:60px;left:8px;right:8px;background:rgba(0,0,0,0.85);color:#0f0;font:11px/1.4 monospace;padding:8px;border-radius:6px;z-index:99999;pointer-events:none;white-space:pre;';
          document.body.appendChild(dbgPanel);
        }

        var onScroll = function () {
          setScrolled(window.scrollY > 50);

          // Lazy lookup if not found yet
          if (!aboutEl) {
            aboutEl = document.getElementById('about');
            if (aboutEl) darkDiv = aboutEl.parentElement;
          }

          // Logo color: direct DOM check on every scroll tick
          if (darkDiv && logo) {
            var rect = darkDiv.getBoundingClientRect();
            var isDark = rect.top <= navH && rect.bottom > navH;
            logo.style.color = isDark ? '#F0F1FA' : '#0a0a12';
          }

          // Crossfade: detect About section (always set targets, even before sound unlocks)
          if (aboutEl) {
            var rect = aboutEl.getBoundingClientRect();
            var vh = window.innerHeight;
            if (rect.top < vh * 0.5) {
              if (globalSoundOn) startSpaceLoop();
              musicTargetVol = 0;
              spaceTargetVol = 0.35;
            } else {
              musicTargetVol = 0.3;
              spaceTargetVol = 0;
            }

            // Debug overlay update
            if (dbgPanel) {
              dbgPanel.textContent =
                'aboutEl: ' + (aboutEl ? 'FOUND' : 'NULL') +
                '\nrect.top: ' + Math.round(rect.top) +
                '\nvh*0.5: ' + Math.round(vh * 0.5) +
                '\ntop<vh*0.5: ' + (rect.top < vh * 0.5) +
                '\nglobalSoundOn: ' + globalSoundOn +
                '\nmusicTargetVol: ' + musicTargetVol +
                '\nmusic.vol(gain): ' + getMusicVol().toFixed(3) +
                '\nmusic.paused: ' + globalMusic.paused +
                '\ncrossfadeRAF: ' + (crossfadeRAF ? 'RUNNING' : 'null') +
                '\nspaceStarted: ' + spaceStarted +
                '\nspaceTargetVol: ' + spaceTargetVol +
                '\nscrollY: ' + Math.round(window.scrollY);
            }
          } else {
            // aboutEl not found yet
            if (dbgPanel) {
              dbgPanel.textContent = 'aboutEl: NULL (not found yet)\nscrollY: ' + Math.round(window.scrollY);
            }
          }

          // Гарантируем что crossfade RAF loop работает
          if (globalSoundOn && !crossfadeRAF) {
            startCrossfade();
          }
        };
        var removeScroll = addScrollListener(onScroll);

        return function () {
          removeScroll();
          if (cacheTimer) clearTimeout(cacheTimer);
          if (dbgPanel && dbgPanel.parentNode) dbgPanel.parentNode.removeChild(dbgPanel);
        };
      }, []);

      // Try to start audio on every gesture until it works
      useEffect(() => {
        var tryPlay = function () {
          if (audioStarted.current) return;
          // Resume AudioContext (iOS requires user gesture)
          if (audioGainCtx && audioGainCtx.state === 'suspended') {
            audioGainCtx.resume();
          }
          globalMusic.play().then(function () {
            audioStarted.current = true;
            globalSoundOn = true;
            startCrossfade();
            // Проверяем — может юзер уже проскроллил до About
            var aboutNow = document.getElementById('about');
            var inAbout = false;
            if (aboutNow) {
              var aRect = aboutNow.getBoundingClientRect();
              inAbout = aRect.top < window.innerHeight * 0.5;
            }
            if (inAbout) {
              musicTargetVol = 0;
              spaceTargetVol = 0.35;
              setMusicVol(0);
            } else {
              musicTargetVol = 0.3;
              spaceTargetVol = 0;
            }
            // Prime spaceA через play() — ОБЯЗАТЕЛЬНО внутри gesture chain для iOS
            setSpaceAVol(0);
            spaceA.play().then(function () {
              if (inAbout) {
                startSpaceLoop();
              } else {
                spaceA.pause();
                spaceA.currentTime = 0;
              }
            }).catch(function () {});
          }).catch(function () { });
        };
        // Only real user activation events (not scroll/wheel/touchmove/mousemove)
        var events = ['click', 'touchstart', 'mousedown', 'keydown'];
        events.forEach(function (e) {
          document.addEventListener(e, tryPlay, {
            passive: true
          });
        });
        return function () {
          events.forEach(function (e) {
            document.removeEventListener(e, tryPlay);
          });
        };
      }, []);
      useEffect(() => {
        globalSoundOn = soundOn;
        if (soundOn) {
          startCrossfade();
          if (audioStarted.current) {
            globalMusic.play().catch(function () { });
          }
          musicTargetVol = 0.3;
        } else {
          globalMusic.pause();
          stopSpaceLoop();
          musicTargetVol = 0;
          spaceTargetVol = 0;
        }
      }, [soundOn]);
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("nav", {
        style: {
          position: 'fixed',
          width: '100%',
          zIndex: 9000,
          fontSize: isMob ? '16px' : '20px',
          top: 0,
          left: 0,
          right: 0,
          transition: 'padding 0.3s ease, opacity 0.4s ease, transform 0.4s ease',
          paddingTop: scrolled ? '8px' : isMob ? '12px' : '38px',
          paddingBottom: scrolled ? '8px' : '0px',
          opacity: hideNav ? 0 : 1,
          transform: hideNav ? 'translateY(-100%)' : 'translateY(0)',
          pointerEvents: hideNav ? 'none' : 'auto'
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          paddingBottom: '0.1em',
          paddingLeft: '5%',
          paddingRight: '5%',
          overflow: 'hidden'
        }
      }, /*#__PURE__*/React.createElement("div", {
        ref: logoRef,
        style: {
          fontFamily: 'Archivo, sans-serif',
          fontWeight: 500,
          fontSize: isMob ? '1.5em' : '2em',
          color: '#0a0a12',
          letterSpacing: '-0.03em',
          textTransform: 'uppercase'
        }
      }, "STUN"), /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '8px'
        }
      }, /*#__PURE__*/React.createElement(MagneticWrap, {
        strength: 0.4
      }, /*#__PURE__*/React.createElement("button", {
        onClick: () => setSoundOn(!soundOn),
        style: {
          fontSize: '0.9em',
          width: '3.2em',
          height: '3.2em',
          borderRadius: '50%',
          border: 'none',
          background: 'rgb(43, 46, 58)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'none',
          transition: 'background 0.3s'
        },
        title: soundOn ? 'Выключить звук' : 'Включить звук'
      }, /*#__PURE__*/React.createElement("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        style: {
          overflow: 'hidden'
        }
      }, soundOn ? /*#__PURE__*/React.createElement("g", {
        style: {
          animation: 'waveShift 0.6s linear infinite'
        }
      }, /*#__PURE__*/React.createElement("path", {
        d: "M-12 12 Q-9 7, -6 12 Q-3 17, 0 12 Q3 7, 6 12 Q9 17, 12 12 Q15 7, 18 12 Q21 17, 24 12 Q27 7, 30 12 Q33 17, 36 12",
        stroke: "#fff",
        strokeWidth: "2",
        fill: "none"
      })) : /*#__PURE__*/React.createElement("line", {
        x1: "4",
        y1: "12",
        x2: "20",
        y2: "12",
        stroke: "#fff",
        strokeWidth: "2",
        strokeLinecap: "round"
      })))), !isMob && /*#__PURE__*/React.createElement(MagneticWrap, {
        strength: 0.4
      }, /*#__PURE__*/React.createElement("a", {
        href: "#contact",
        style: {
          background: 'rgb(43, 46, 58)',
          color: '#fff',
          fontSize: '0.9em',
          fontWeight: 500,
          fontFamily: 'Archivo, sans-serif',
          textTransform: 'uppercase',
          height: '3.2em',
          borderRadius: '106px',
          paddingLeft: '1.625em',
          paddingRight: '1.125em',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          textDecoration: 'none',
          cursor: 'none',
          transition: 'background 0.3s'
        }
      }, "Let's talk", /*#__PURE__*/React.createElement("span", {
        style: {
          position: 'relative',
          width: '1.15em',
          height: '1.15em',
          flexShrink: 0
        }
      }, /*#__PURE__*/React.createElement("span", {
        style: {
          backgroundColor: '#fff',
          position: 'absolute',
          left: '50%',
          top: '50%',
          transform: 'translate(-50%, -50%)',
          width: '0.3125em',
          height: '0.3125em',
          borderRadius: '100%',
          display: 'block'
        }
      })))), /*#__PURE__*/React.createElement(MagneticWrap, {
        strength: 0.4
      }, /*#__PURE__*/React.createElement("button", {
        onClick: () => setMenuOpen(!menuOpen),
        style: {
          background: 'rgb(228, 230, 239)',
          color: '#000',
          fontSize: '0.9em',
          fontWeight: 500,
          fontFamily: 'Archivo, sans-serif',
          textTransform: 'uppercase',
          height: '3.2em',
          borderRadius: '106px',
          paddingLeft: '1.625em',
          paddingRight: '1.125em',
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          border: 'none',
          cursor: 'none',
          transition: 'background 0.3s'
        }
      }, /*#__PURE__*/React.createElement("span", {
        style: {
          display: 'inline-grid',
          overflow: 'hidden',
          height: '1.2em',
          alignItems: 'center'
        }
      }, /*#__PURE__*/React.createElement("span", {
        style: {
          gridArea: '1 / 1',
          transition: 'transform 0.3s, opacity 0.3s',
          transform: menuOpen ? 'translateY(-100%)' : 'translateY(0)',
          opacity: menuOpen ? 0 : 1
        }
      }, "Menu"), /*#__PURE__*/React.createElement("span", {
        style: {
          gridArea: '1 / 1',
          transition: 'transform 0.3s, opacity 0.3s',
          transform: menuOpen ? 'translateY(0)' : 'translateY(100%)',
          opacity: menuOpen ? 1 : 0
        }
      }, "Close")), /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'relative',
          width: '1.15em',
          height: '1.15em',
          flexShrink: 0
        }
      }, /*#__PURE__*/React.createElement("span", {
        style: {
          backgroundColor: '#000',
          position: 'absolute',
          left: '0.15em',
          top: '50%',
          transform: 'translateY(-50%)',
          display: 'inline-block',
          width: '0.3125em',
          height: '0.3125em',
          borderRadius: '100%'
        }
      }), /*#__PURE__*/React.createElement("span", {
        style: {
          backgroundColor: '#000',
          position: 'absolute',
          right: '0.15em',
          top: '50%',
          transform: 'translateY(-50%)',
          display: 'inline-block',
          width: '0.3125em',
          height: '0.3125em',
          borderRadius: '100%'
        }
      }))))))), /*#__PURE__*/React.createElement("div", {
        className: 'fixed inset-0 z-[8999] bg-[#f0f1fa] transition-all duration-500 flex flex-col justify-center items-center ' + (menuOpen && !hideNav ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'),
        style: {
          gap: isMob ? '16px' : '32px'
        }
      }, /*#__PURE__*/React.createElement("a", {
        href: "#services",
        onClick: () => setMenuOpen(false),
        className: "text-4xl md:text-6xl font-display hover:text-accent transition",
        style: {
          padding: '12px 24px',
          minHeight: '56px',
          display: 'flex',
          alignItems: 'center'
        }
      }, "\u0423\u0441\u043B\u0443\u0433\u0438"), /*#__PURE__*/React.createElement("a", {
        href: "#about",
        onClick: () => setMenuOpen(false),
        className: "text-4xl md:text-6xl font-display hover:text-accent transition",
        style: {
          padding: '12px 24px',
          minHeight: '56px',
          display: 'flex',
          alignItems: 'center'
        }
      }, "\u041E \u043D\u0430\u0441"), /*#__PURE__*/React.createElement("a", {
        href: "#contact",
        onClick: () => setMenuOpen(false),
        className: "text-4xl md:text-6xl font-display hover:text-accent transition",
        style: {
          padding: '12px 24px',
          minHeight: '56px',
          display: 'flex',
          alignItems: 'center'
        }
      }, "\u041A\u043E\u043D\u0442\u0430\u043A\u0442\u044B")));
    }

    // ========== THE PROCESS (HORIZONTAL TIMELINE) ==========
    function ProcessManifesto() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      var steps = [{
        id: '01',
        title: 'DISCOVERY',
        desc: 'Глубокое погружение бизнес.<br />Создаем креативную концепцию.'
      }, {
        id: '02',
        title: 'PROTOTYPE',
        desc: 'Проектируем логику и UX.<br />Разрабатываем прототипы проектов.'
      }, {
        id: '03',
        title: 'WEBGL / 3D',
        desc: 'Отрисовываем UI и 3D-ассеты.<br />Пишем шейдеры и анимации.'
      }, {
        id: '04',
        title: 'LAUNCH',
        desc: 'Оптимизация 60 FPS и SEO.<br />Релиз и развитие продукта.'
      }];
      return /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'flex',
          flexDirection: isMob ? 'column' : 'row',
          height: isMob ? 'auto' : '80vh',
          width: isMob ? '100%' : 'max-content',
          padding: isMob ? '40px 5vw' : '0 15vw',
          alignItems: isMob ? 'flex-start' : 'center',
          gap: isMob ? '80px' : '15vw',
          position: 'relative'
        }
      }, steps.map(function (s, i) {
        return /*#__PURE__*/React.createElement("div", {
          key: i,
          style: {
            flexShrink: 0,
            width: isMob ? '90vw' : '65vw',
            paddingLeft: 0,
            position: 'relative',
            zIndex: 1,
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center'
          }
        }, /*#__PURE__*/React.createElement("div", {
          style: {
            fontFamily: 'Unbounded, sans-serif',
            fontSize: isMob ? '80px' : '180px',
            fontWeight: 800,
            color: 'transparent',
            WebkitTextStroke: '2px rgba(255,255,255,0.2)',
            lineHeight: 1,
            marginBottom: isMob ? '20px' : '30px',
            position: 'relative',
            display: 'inline-block'
          }
        }, s.id), /*#__PURE__*/React.createElement("h3", {
          style: {
            fontFamily: 'Onest, sans-serif',
            fontSize: isMob ? '48px' : '110px',
            fontWeight: 900,
            color: '#fff',
            textTransform: 'uppercase',
            marginBottom: isMob ? '20px' : '30px',
            letterSpacing: '3.2px',
            lineHeight: 1.1,
            whiteSpace: isMob ? 'nowrap' : 'normal'
          }
        }, s.title), /*#__PURE__*/React.createElement("p", {
          style: {
            fontFamily: 'Onest, sans-serif',
            fontSize: isMob ? '20px' : '36px',
            fontWeight: 900,
            color: 'rgba(255,255,255,0.35)',
            textTransform: 'uppercase',
            letterSpacing: '3.2px',
            lineHeight: 1.4,
            maxWidth: '95%'
          },
          dangerouslySetInnerHTML: {
            __html: s.desc
          }
        }));
      }));
    }

    // ========== ABOUT — HORIZONTAL SCROLL ==========
    function AboutSection() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      var sectionRef = useRef(null);
      var trackRef = useRef(null);
      var scrollPRef = useRef(0);
      var smoothP = useRef(0);
      var statsRef = useRef([]);
      var countDone = useRef(false);
      var animRef = useRef(null);
      var stats = [{
        value: 50,
        suffix: '+',
        label: 'Проектов'
      }, {
        value: 12,
        suffix: '',
        label: 'В команде'
      }, {
        value: 1,
        suffix: 'M+',
        label: 'Строк кода'
      }, {
        value: 10,
        suffix: '+',
        label: 'Индустрий'
      }];
      useEffect(function () {
        var section = sectionRef.current;
        var track = trackRef.current;
        if (!section || !track) return;
        if (!isMob) {
          var onScroll = function () {
            var rect = section.getBoundingClientRect();
            var total = section.offsetHeight - window.innerHeight;
            if (total <= 0) return;
            scrollPRef.current = Math.max(0, Math.min(1, -rect.top / total));
          };
          var removeScroll = addScrollListener(onScroll);

          var aboutVisible = false;
          var aboutObs = new IntersectionObserver(function (entries) {
            aboutVisible = entries[0].isIntersecting;
            if (aboutVisible && !animRef.current) animRef.current = requestAnimationFrame(tick);
          }, { rootMargin: '100px', threshold: 0 });
          aboutObs.observe(section);
          var tick = function () {
            if (!aboutVisible) { animRef.current = null; return; }
            smoothP.current += (scrollPRef.current - smoothP.current) * 0.25;
            var p = smoothP.current;
            var vw = window.innerWidth;
            var trackW = track.scrollWidth;
            var maxShift = (trackW - vw) * 0.96;
            var tx = -p * maxShift;
            track.style.transform = 'translateX(' + tx + 'px)';
            animRef.current = requestAnimationFrame(tick);
          };
          animRef.current = requestAnimationFrame(tick);
          onScroll();
        }

        // Count-up when stats become visible
        var statsObs = new IntersectionObserver(function (entries) {
          if (entries[0].isIntersecting && !countDone.current) {
            countDone.current = true;
            var dur = 2000;
            var t0 = performance.now();
            var countTick = function (now) {
              var cp = Math.min(1, (now - t0) / dur);
              var ease = 1 - Math.pow(1 - cp, 3);
              for (var i = 0; i < stats.length; i++) {
                if (statsRef.current[i]) {
                  statsRef.current[i].textContent = Math.round(stats[i].value * ease) + stats[i].suffix;
                }
              }
              if (cp < 1) requestAnimationFrame(countTick);
            };
            requestAnimationFrame(countTick);
            statsObs.disconnect();
          }
        }, {
          threshold: 0.1
        });
        if (statsRef.current[0]) statsObs.observe(statsRef.current[0]);
        return function () {
          if (!isMob) {
            removeScroll();
            if (animRef.current) cancelAnimationFrame(animRef.current);
            if (aboutObs) aboutObs.disconnect();
          }
          statsObs.disconnect();
        };
      }, [isMob]);
      return /*#__PURE__*/React.createElement("section", {
        ref: sectionRef,
        id: "about",
        style: {
          position: 'relative',
          background: 'inherit',
          borderRadius: '48px 48px 0 0',
          marginTop: '-100vh',
          zIndex: 2,
          boxShadow: '0 -20px 60px rgba(0,0,0,0.5)',
          height: isMob ? 'auto' : '500vh',
          paddingBottom: isMob ? '80px' : '0'
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          position: isMob ? 'relative' : 'sticky',
          top: 0,
          height: isMob ? 'auto' : '100vh',
          overflow: isMob ? 'visible' : 'hidden',
          display: 'flex',
          alignItems: isMob ? 'flex-start' : 'center'
        }
      }, /*#__PURE__*/React.createElement("div", {
        ref: trackRef,
        style: {
          display: 'flex',
          alignItems: isMob ? 'flex-start' : 'stretch',
          gap: 0,
          flexDirection: isMob ? 'column' : 'row',
          width: '100%',
          willChange: isMob ? 'auto' : 'transform'
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          flexShrink: 0,
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          height: isMob ? 'min-content' : '100vh',
          padding: isMob ? '120px 5vw 80px' : '0 8vw',
          width: isMob ? '100%' : 'auto'
        }
      }, /*#__PURE__*/React.createElement("h2", {
        style: {
          fontSize: isMob ? '14vw' : '17vw',
          fontWeight: 500,
          lineHeight: 0.9,
          color: '#fff',
          fontFamily: 'Archivo, sans-serif',
          textTransform: 'uppercase',
          letterSpacing: '-0.04em',
          whiteSpace: isMob ? 'normal' : 'nowrap'
        }
      }, "BEYOND ", /*#__PURE__*/React.createElement("span", {
        style: {
          color: '#1a2ffb'
        }
      }, "LIMITS")), /*#__PURE__*/React.createElement("div", {
        style: {
          display: isMob ? 'grid' : 'flex',
          gridTemplateColumns: isMob ? '1fr 1fr' : undefined,
          gap: isMob ? '40px 16px' : undefined,
          justifyContent: isMob ? undefined : 'space-between',
          marginTop: isMob ? '40px' : '5vh',
          width: '100%'
        }
      }, stats.map(function (s, i) {
        return /*#__PURE__*/React.createElement("div", {
          key: i,
          style: {
            textAlign: isMob ? 'left' : 'center',
            minWidth: isMob ? undefined : '12vw'
          }
        }, /*#__PURE__*/React.createElement("p", {
          ref: function (el) {
            statsRef.current[i] = el;
          },
          style: {
            fontSize: isMob ? 'clamp(2rem, 12vw, 4rem)' : 'clamp(7rem, 12vw, 14rem)',
            fontWeight: 600,
            fontFamily: 'Unbounded, sans-serif',
            color: '#fff',
            lineHeight: 1,
            letterSpacing: '-0.02em'
          }
        }, "0", s.suffix), /*#__PURE__*/React.createElement("p", {
          style: {
            fontSize: isMob ? '16px' : '36px',
            color: 'rgba(255,255,255,0.35)',
            textTransform: 'uppercase',
            letterSpacing: isMob ? '1.5px' : '3.2px',
            marginTop: isMob ? '10px' : '20px',
            fontFamily: 'Onest, sans-serif',
            fontWeight: 900,
            lineHeight: 'normal'
          }
        }, s.label));
      }))), /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: isMob ? 'flex-start' : 'center',
          width: isMob ? '100%' : 'auto'
        }
      }, /*#__PURE__*/React.createElement(ProcessManifesto, null)))));
    }

    // ========== SERVICE ITEM ==========
    function CardServices() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      var sectionRef = useRef(null);
      var cardsRef = useRef([]);
      var cardsBoxRef = useRef(null);
      var labelRef = useRef(null);
      var expertiseRef = useRef(null);
      var descRef = useRef(null);
      var animRef = useRef(null);
      var scrollPRef = useRef(0);
      var inViewRef = useRef(false);
      var services = [{
        num: '01',
        title: 'Design',
        letter: 'D',
        items: ['UX/UI Дизайн', 'Дизайн-системы', 'Прототипы']
      }, {
        num: '02',
        title: 'Web',
        letter: 'W',
        items: ['React / Next.js', 'Three.js / WebGL', 'Анимации']
      }, {
        num: '03',
        title: 'Copy',
        letter: 'C',
        items: ['Рерайт и копирайт', 'Дипломные работы', 'Научные статьи']
      }, {
        num: '04',
        title: 'Dev & AI',
        letter: 'A',
        items: ['Telegram-боты', 'ИИ-интеграция', 'Автоматизация']
      }];
      useEffect(function () {
        var section = sectionRef.current;
        if (!section) return;
        if (isMob) {
          // Mobile: flip cards on scroll into view
          var cardEls = cardsRef.current.filter(Boolean);
          var flipObs = new IntersectionObserver(function (entries) {
            entries.forEach(function (entry) {
              if (entry.isIntersecting) {
                var idx = cardEls.indexOf(entry.target);
                var delay = idx >= 0 ? idx * 150 : 0;
                setTimeout(function () {
                  entry.target.classList.add('flipped');
                }, delay);
                flipObs.unobserve(entry.target);
              }
            });
          }, {
            threshold: 0.3
          });
          cardEls.forEach(function (el) {
            flipObs.observe(el);
          });

          // Make cards container sticky so About can overlap the last card
          var stickyWrap = sectionRef.current.querySelector('[data-cards-wrap]');
          if (stickyWrap) {
            var contentH = stickyWrap.scrollHeight;
            var vh = window.innerHeight;
            var stickyTop = -(contentH - vh);
            stickyWrap.style.position = 'sticky';
            stickyWrap.style.top = stickyTop + 'px';
            // Set section height so there's scroll room for the overlap + extra buffer for last card visibility
            section.style.height = contentH + vh * 1.8 + 'px';
          }
          return function () {
            flipObs.disconnect();
          };
        }
        var onScroll = function () {
          var rect = section.getBoundingClientRect();
          var total = section.offsetHeight - window.innerHeight;
          if (total <= 0) return;
          scrollPRef.current = Math.max(0, Math.min(1, -rect.top / total));
        };
        var removeScroll = addScrollListener(onScroll);

        var observer = { disconnect: function () { } };
        var t0 = performance.now();
        // Smoothed scroll value for buttery interpolation
        var smoothP = 0;
        // Visibility gating — stop rAF when section off-screen
        var cardsVisible = false;
        var cardsObs = new IntersectionObserver(function (entries) {
          cardsVisible = entries[0].isIntersecting;
          if (cardsVisible && !animRef.current) animRef.current = requestAnimationFrame(animate);
        }, { rootMargin: '100px', threshold: 0 });
        cardsObs.observe(section);
        var animate = function (now) {
          if (!cardsVisible) { animRef.current = null; return; }
          var t = (now - t0) / 1000;

          // Lerp scroll position — clamped max speed so fast scrolling doesn't affect animation pace
          var delta = scrollPRef.current - smoothP;
          var step = delta * 0.08;
          var maxStep = 0.004;
          step = Math.sign(step) * Math.min(Math.abs(step), maxStep);
          smoothP += step;
          var p = smoothP;
          var vw = window.innerWidth;
          var cardW = 420;
          var gap = 40;
          var totalW = cardW * 4 + gap * 3;
          var sc = Math.min(1, vw * 0.92 / totalW);
          var spacing = (cardW + gap) * sc;

          // Quintic ease in-out for ultra smooth
          var smoothEase = function (x) {
            return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;
          };
          var sectionTotal = sectionRef.current ? sectionRef.current.offsetHeight - window.innerHeight : 1;
          var scrollPx = p * sectionTotal;

          // === RAW scroll (no lerp) for both text AND card settle ===
          var rawPx = scrollPRef.current * sectionTotal;

          // Cards start BELOW text, settle UP to center — uses RAW scroll so cards don't overlap text when scrolling up
          var cardStartY = 450;
          var settleEnd = 400;
          var settleP = Math.min(1, rawPx / settleEnd);
          var easeOut = function (x) {
            return 1 - Math.pow(1 - x, 3);
          };
          var cardSettleY = cardStartY * (1 - easeOut(settleP));

          // === TEXT: uses RAW scroll (no lerp) so it's instant, no "flying in" ===
          if (labelRef.current) {
            labelRef.current.style.transform = 'translateY(' + -rawPx + 'px)';
          }

          // === ONE continuous animation from start to end ===
          var ap = Math.min(1, scrollPx / sectionTotal);


          // COLLECT phase: ap 0.55→0.70 unflip, ap 0.70→0.90 unfan
          var unflipP = Math.max(0, Math.min(1, (ap - 0.55) / 0.15));
          var unflipEase = smoothEase(unflipP);
          var unfanP = Math.max(0, Math.min(1, (ap - 0.70) / 0.20));
          var unfanEase = smoothEase(unfanP);
          cardsRef.current.forEach(function (card, i) {
            if (!card) return;

            // CASCADE (ap 0→0.15)
            var cascP = Math.max(0, Math.min(1, ap / 0.15));
            var cascEase = easeOut(cascP);

            // FAN (ap 0.10→0.22)
            var fanDelay = 0.10 + i * 0.012;
            var fanP = Math.max(0, Math.min(1, (ap - fanDelay) / 0.12));
            var fanEase = smoothEase(fanP);

            // FLIP (ap 0.25→0.40) — earlier, less scroll needed
            var flipDelay = 0.25 + i * 0.02;
            var flipP = Math.max(0, Math.min(1, (ap - flipDelay) / 0.15));
            var flipEase = smoothEase(flipP);

            // Apply COLLECT: reverse fan and flip
            var effectiveFan = fanEase * (1 - unfanEase);
            var effectiveCascade = cascEase * (1 - unfanEase);
            var effectiveFlip = flipEase * (1 - unflipEase);
            var rotY = 180 * (1 - effectiveFlip);

            // Front/back handled by backface-visibility + 3D transform

            // Fan target
            var tx = (-1.5 + i) * spacing;

            // Drift — diminishes during collect
            var driftFactor = 1 - unfanEase;
            var ph = i * 1.9;
            var driftAmp = 80;
            var driftX = (Math.sin(t * 0.4 + ph) * driftAmp * 0.3 + Math.sin(t * 0.25 + ph * 2.3) * (driftAmp * 0.15)) * driftFactor;
            var driftY = (Math.cos(t * 0.35 + ph * 1.4) * driftAmp + Math.cos(t * 0.2 + ph * 0.8) * (driftAmp * 0.5)) * driftFactor;
            var driftRot = Math.sin(t * 0.1 + ph * 0.6) * 1.5 * driftFactor;
            var cascadeX = i * 15 * effectiveCascade;
            var cascadeY = i * 10 * effectiveCascade;

            // Blend: cascade → fan, reversed by collect
            var x = cascadeX * (1 - effectiveFan) + tx * effectiveFan + driftX;
            var y = cardSettleY + cascadeY * (1 - effectiveFan) + driftY;
            if (y < 0) y = 0;
            var rotZ = driftRot;
            card.style.transform = 'perspective(1200px) translateX(' + x + 'px) translateY(' + y + 'px) rotateY(' + rotY + 'deg) rotate(' + rotZ + 'deg) scale(' + sc + ')';
          });
          animRef.current = requestAnimationFrame(animate);
        };
        animRef.current = requestAnimationFrame(animate);
        onScroll();

        // EXPERTISE slides right when scrolled into view
        var expObs = new IntersectionObserver(function (entries) {
          if (entries[0].isIntersecting && expertiseRef.current) {
            setTimeout(function () {
              expertiseRef.current.style.paddingLeft = '33vw';
            }, 600);
            expObs.disconnect();
          }
        }, { threshold: 0.3 });
        if (expertiseRef.current) expObs.observe(expertiseRef.current);

        return function () {
          removeScroll();
          if (animRef.current) cancelAnimationFrame(animRef.current);
          observer.disconnect();
          expObs.disconnect();
          cardsObs.disconnect();
        };
      }, [isMob]);
      var cardW = isMob ? 280 : 420,
        cardH = isMob ? 520 : 560;
      return /*#__PURE__*/React.createElement("section", {
        ref: sectionRef,
        id: "services",
        style: {
          height: isMob ? 'auto' : '530vh',
          position: 'relative',
          background: '#f0f1fa',
          zIndex: 1,
          marginTop: '-1px'
        }
      }, /*#__PURE__*/React.createElement("div", {
        "data-cards-wrap": "",
        style: {
          position: isMob ? 'relative' : 'sticky',
          top: 0,
          height: isMob ? 'auto' : '100vh',
          display: 'flex',
          flexDirection: isMob ? 'column' : 'row',
          alignItems: isMob ? 'flex-start' : 'center',
          justifyContent: isMob ? 'flex-start' : 'center',
          paddingTop: isMob ? '40px' : '0'
        }
      }, /*#__PURE__*/React.createElement("div", {
        ref: labelRef,
        style: {
          position: isMob ? 'relative' : 'absolute',
          top: isMob ? '0' : '100px',
          left: isMob ? '5vw' : '5%',
          right: isMob ? '5vw' : '5%',
          width: isMob ? '90vw' : 'auto',
          marginBottom: isMob ? '0' : '0',
          zIndex: 20
        }
      }, /*#__PURE__*/React.createElement("h2", {
        style: {
          fontSize: isMob ? 'clamp(2.2rem, 9vw, 3.5rem)' : 'clamp(3.5rem, 10vw, 11rem)',
          fontWeight: 500,
          lineHeight: 0.88,
          letterSpacing: '-0.02em',
          color: '#1a2ffb',
          textTransform: 'uppercase',
          fontFamily: 'Archivo, sans-serif'
        }
      }, "AREA OF", /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement("span", {
        ref: expertiseRef,
        style: {
          position: 'relative',
          display: 'inline-block',
          paddingLeft: '0',
          transition: 'padding-left 1.2s cubic-bezier(0.16, 1, 0.3, 1)'
        }
      }, "EXPERTISE")), /*#__PURE__*/React.createElement("div", {
        ref: descRef,
        style: {
          position: isMob ? 'relative' : 'absolute',
          top: isMob ? 'auto' : '0',
          marginTop: isMob ? '20px' : '0',
          bottom: 'auto',
          right: isMob ? 'auto' : 'calc(100% - 83vw)',
          left: isMob ? '0' : 'auto',
          height: isMob ? 'auto' : '8.8vw',
          display: isMob ? 'block' : 'flex',
          alignItems: 'center',
          maxWidth: '458px',
          width: 'max-content',
          letterSpacing: 'normal',
          textTransform: 'none',
          lineHeight: 'normal',
          opacity: 1
        }
      }, /*#__PURE__*/React.createElement("p", {
        style: {
          fontSize: isMob ? '14px' : '20px',
          textTransform: 'uppercase',
          letterSpacing: '1.6px',
          lineHeight: isMob ? 1.4 : '27.2px',
          color: '#888888',
          fontWeight: 500,
          fontFamily: 'Onest, sans-serif',
          textAlign: 'left',
          margin: 0
        }
      }, "\u041A\u043E\u043C\u0430\u043D\u0434\u0430 \u043E\u043F\u044B\u0442\u043D\u044B\u0445 \u0441\u043F\u0435\u0446\u0438\u0430\u043B\u0438\u0441\u0442\u043E\u0432 \u0441", /*#__PURE__*/React.createElement("br", null), "\u0448\u0438\u0440\u043E\u043A\u0438\u043C \u0441\u043F\u0435\u043A\u0442\u0440\u043E\u043C \u043D\u0430\u0432\u044B\u043A\u043E\u0432", /*#__PURE__*/React.createElement("br", null), "\u0438 \u043A\u043E\u043C\u043F\u0435\u0442\u0435\u043D\u0446\u0438\u0439"))), /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'relative',
          width: isMob ? '92vw' : cardW + 'px',
          height: isMob ? 'auto' : cardH + 'px',
          display: isMob ? 'flex' : 'block',
          flexDirection: 'column',
          gap: isMob ? '40px' : '0',
          marginLeft: isMob ? '4vw' : '0',
          marginTop: isMob ? '20px' : '0',
          perspective: 'none'
        }
      }, services.map(function (s, i) {
        return /*#__PURE__*/React.createElement("div", {
          key: i,
          ref: function (el) {
            cardsRef.current[i] = el;
          },
          className: isMob ? 'mobile-card-flip' : undefined,
          style: {
            position: isMob ? 'relative' : 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: isMob ? cardH + 'px' : cardH + 'px',
            borderRadius: '20px',
            zIndex: 10 + i,
            willChange: isMob ? 'auto' : 'transform',
            transformOrigin: 'center center',
            transformStyle: 'preserve-3d'
          }
        }, /*#__PURE__*/React.createElement("div", {
          "data-back": "",
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            borderRadius: '20px',
            background: 'linear-gradient(145deg, #2238fc 0%, #0d1a9e 100%)',
            boxShadow: '0 25px 80px rgba(26,47,251,0.25), 0 8px 20px rgba(0,0,0,0.1)',
            overflow: 'hidden',
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)'
          }
        }, /*#__PURE__*/React.createElement("svg", {
          viewBox: "0 0 420 560",
          fill: "none",
          xmlns: "http://www.w3.org/2000/svg",
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%'
          }
        }, /*#__PURE__*/React.createElement("g", {
          stroke: "rgba(255,255,255,0.7)",
          strokeWidth: "2.5",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }, /*#__PURE__*/React.createElement("rect", {
          x: "16",
          y: "16",
          width: "388",
          height: "528",
          rx: "10",
          strokeWidth: "3"
        }), /*#__PURE__*/React.createElement("rect", {
          x: "28",
          y: "28",
          width: "364",
          height: "504",
          rx: "6",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "28",
          r: "8"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "28",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "28",
          r: "8"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "28",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "532",
          r: "8"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "532",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "532",
          r: "8"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "532",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("path", {
          d: "M 145 28 Q 210 95 275 28"
        }), /*#__PURE__*/React.createElement("path", {
          d: "M 165 28 Q 210 75 255 28"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "58",
          r: "10"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "58",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "186",
          y1: "42",
          x2: "234",
          y2: "42",
          strokeWidth: "3.5"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "192",
          y1: "76",
          x2: "228",
          y2: "76",
          strokeWidth: "3.5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "178",
          cy: "58",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "242",
          cy: "58",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("path", {
          d: "M 145 532 Q 210 465 275 532"
        }), /*#__PURE__*/React.createElement("path", {
          d: "M 165 532 Q 210 485 255 532"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "502",
          r: "10"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "502",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "186",
          y1: "518",
          x2: "234",
          y2: "518",
          strokeWidth: "3.5"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "192",
          y1: "484",
          x2: "228",
          y2: "484",
          strokeWidth: "3.5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "178",
          cy: "502",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "242",
          cy: "502",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "130",
          x2: "130",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "170",
          x2: "170",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "210",
          x2: "210",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "130",
          x2: "290",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "170",
          x2: "250",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "210",
          x2: "210",
          y2: "28",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "430",
          x2: "130",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "390",
          x2: "170",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "28",
          y1: "350",
          x2: "210",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "430",
          x2: "290",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "390",
          x2: "250",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "392",
          y1: "350",
          x2: "210",
          y2: "532",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "210",
          y1: "90",
          x2: "210",
          y2: "195"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "210",
          y1: "365",
          x2: "210",
          y2: "470"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "60",
          y1: "280",
          x2: "135",
          y2: "280"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "285",
          y1: "280",
          x2: "360",
          y2: "280"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "130",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "430",
          r: "3",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "280",
          r: "5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "28",
          cy: "280",
          r: "2",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "280",
          r: "5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "392",
          cy: "280",
          r: "2",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "28",
          r: "5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "28",
          r: "2",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "532",
          r: "5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "532",
          r: "2",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("polygon", {
          points: "210,155 335,280 210,405 85,280",
          strokeWidth: "1.5"
        }), /*#__PURE__*/React.createElement("polygon", {
          points: "210,180 310,280 210,380 110,280",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("polygon", {
          points: "210,205 285,280 210,355 135,280",
          strokeWidth: "1"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "280",
          r: "52",
          strokeWidth: "2"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "280",
          r: "44",
          strokeWidth: "1"
        }), /*#__PURE__*/React.createElement("path", {
          d: "M 210 240 C 230 240 240 255 240 270 C 250 270 260 280 250 290 C 260 290 260 310 240 310 C 240 320 230 330 210 320 C 190 330 180 320 180 310 C 160 310 160 290 170 290 C 160 280 170 270 180 270 C 180 255 190 240 210 240 Z",
          strokeWidth: "1.5"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "155",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "335",
          cy: "280",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "210",
          cy: "405",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("circle", {
          cx: "85",
          cy: "280",
          r: "4",
          fill: "rgba(255,255,255,0.6)"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "145",
          y1: "215",
          x2: "80",
          y2: "150",
          strokeWidth: "1.5"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "275",
          y1: "215",
          x2: "340",
          y2: "150",
          strokeWidth: "1.5"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "145",
          y1: "345",
          x2: "80",
          y2: "410",
          strokeWidth: "1.5"
        }), /*#__PURE__*/React.createElement("line", {
          x1: "275",
          y1: "345",
          x2: "340",
          y2: "410",
          strokeWidth: "1.5"
        })), /*#__PURE__*/React.createElement("text", {
          x: "210",
          y: "295",
          textAnchor: "middle",
          fill: "rgba(255,255,255,0.75)",
          fontSize: "42",
          fontFamily: "Onest, sans-serif",
          fontWeight: "700"
        }, "S"))), /*#__PURE__*/React.createElement("div", {
          "data-front": "",
          style: {
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            borderRadius: '20px',
            background: '#0a0a0a',
            border: '4px solid #1a2ffb',
            color: '#fff',
            padding: isMob ? '20px 24px' : '32px 40px',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-between',
            boxShadow: '0 25px 80px rgba(26,47,251,0.15), 0 8px 20px rgba(0,0,0,0.06)',
            backfaceVisibility: 'hidden'
          }
        }, /*#__PURE__*/React.createElement("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
          }
        }, /*#__PURE__*/React.createElement("p", {
          style: {
            fontSize: isMob ? '34px' : '42px',
            textTransform: 'uppercase',
            fontWeight: 700,
            letterSpacing: '-0.02em'
          }
        }, s.title), /*#__PURE__*/React.createElement("div", {
          style: {
            fontSize: isMob ? '60px' : '80px',
            fontWeight: 200,
            color: '#1a2ffb',
            lineHeight: 0.9
          }
        }, s.letter)), /*#__PURE__*/React.createElement("ul", {
          style: {
            listStyleType: 'none',
            padding: 0,
            margin: 0
          }
        }, s.items.map(function (item, j) {
          return /*#__PURE__*/React.createElement("li", {
            key: j,
            style: {
              fontSize: isMob ? '24px' : '28px',
              color: 'rgba(255,255,255,0.5)',
              padding: isMob ? '14px 0' : '10px 0',
              borderBottom: j < s.items.length - 1 ? (isMob ? '1px' : '5px') + ' ' + (isMob ? 'solid' : 'dotted') + ' rgba(255,255,255,0.15)' : 'none',
              fontWeight: 500
            }
          }, item);
        })), /*#__PURE__*/React.createElement("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            transform: 'rotate(180deg)'
          }
        }, /*#__PURE__*/React.createElement("p", {
          style: {
            fontSize: isMob ? '34px' : '42px',
            textTransform: 'uppercase',
            fontWeight: 700,
            letterSpacing: '-0.02em'
          }
        }, s.title), /*#__PURE__*/React.createElement("div", {
          style: {
            fontSize: isMob ? '60px' : '80px',
            fontWeight: 200,
            color: '#1a2ffb',
            lineHeight: 0.9
          }
        }, s.letter))));
      }))));
    }

    // ========== SCROLL REVEAL HOOK ==========
    function useReveal() {
      const ref = useRef(null);
      useEffect(() => {
        var el = ref.current;
        if (!el) return;
        var obs = new IntersectionObserver(entries => {
          entries.forEach(e => {
            if (e.isIntersecting) {
              e.target.classList.add('active');
            }
          });
        }, {
          threshold: 0.15
        });
        el.querySelectorAll('.reveal').forEach(r => obs.observe(r));
        return () => obs.disconnect();
      }, []);
      return ref;
    }

    // ========== APP ==========
    // ========== SMOOTH SCROLL (LENIS) ==========
    function useSmoothScroll() {
      useEffect(() => {
        if (typeof Lenis === 'undefined' || isMobile) return;
        var lenis = new Lenis({
          duration: 1.2,
          easing: function (t) {
            return Math.min(1, 1.001 - Math.pow(2, -10 * t));
          },
          smoothWheel: true
        });
        var raf = function (time) {
          lenis.raf(time);
          requestAnimationFrame(raf);
        };
        requestAnimationFrame(raf);
        return function () {
          lenis.destroy();
        };
      }, []);
    }

    // ========== PARALLAX HERO ==========
    function useHeroParallax(textRef, rectRef, crosshairsRef, scrollLabelRef) {
      useEffect(() => {
        var pf = isMobile ? 0.1 : 0.35;
        var onScroll = function () {
          var scrollY = window.scrollY;
          if (textRef.current) {
            textRef.current.style.transform = 'translateY(' + scrollY * pf + 'px)';
          }
        };
        var removeScroll = addScrollListener(onScroll);
        onScroll();
        return function () {
          removeScroll();
        };
      }, []);
    }
    function LoadingBar({
      onLoaded
    }) {
      var barRef = useRef(null);
      var progress = useRef(0);
      var containerRef = useRef(null);
      useEffect(() => {
        // Block scroll during loading
        document.body.style.overflow = 'hidden';
        var target = 33;
        var steps = [{
          at: 100,
          val: 60
        }, {
          at: 400,
          val: 80
        }, {
          at: 800,
          val: 100
        }];
        var timers = steps.map(function (s) {
          return setTimeout(function () {
            target = s.val;
          }, s.at);
        });
        var aid;
        var tick = function () {
          progress.current += (target - progress.current) * 0.1;
          if (barRef.current) {
            barRef.current.style.width = progress.current + '%';
          }
          if (progress.current > 99.5) {
            document.body.style.overflow = '';
            setTimeout(onLoaded, 150);
            return;
          }
          aid = requestAnimationFrame(tick);
        };
        aid = requestAnimationFrame(tick);
        return function () {
          document.body.style.overflow = '';
          timers.forEach(clearTimeout);
          if (aid) cancelAnimationFrame(aid);
        };
      }, [onLoaded]);
      return /*#__PURE__*/React.createElement("div", {
        ref: containerRef,
        style: {
          position: 'fixed',
          top: '-100px',
          left: 0,
          right: 0,
          bottom: '-100px',
          zIndex: 100000,
          background: '#0a0a0a',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center'
        }
      }, /*#__PURE__*/React.createElement("span", {
        style: {
          fontFamily: 'Archivo, sans-serif',
          fontSize: 'clamp(36px, 5.5vw, 80px)',
          fontWeight: 700,
          color: 'rgba(255,255,255,0.25)',
          textTransform: 'uppercase',
          letterSpacing: '0.05em',
          marginBottom: '20px',
          width: '90%',
          textAlign: 'center'
        }
      }, "\u041F\u043E\u0434\u043E\u0436\u0434\u0438\u0442\u0435, \u043C\u044B \u0441\u0442\u0430\u0440\u0430\u0435\u043C\u0441\u044F..."), /*#__PURE__*/React.createElement("div", {
        style: {
          width: '90%',
          height: isMobile ? '24px' : '40px',
          background: 'rgba(255,255,255,0.15)',
          overflow: 'hidden'
        }
      }, /*#__PURE__*/React.createElement("div", {
        ref: barRef,
        style: {
          width: '33%',
          height: '100%',
          background: '#fff',
          transition: 'none'
        }
      })));
    }

    // ========== SCROLL-DRIVEN VIDEO (WebM with alpha) ==========
    function ScrollVideo() {
      var videoRef = useRef(null);
      var sectionRef = useRef(null);
      useEffect(function () {
        var video = videoRef.current;
        if (!video) return;
        var rafId = null;
        var ready = false;

        video.addEventListener('loadedmetadata', function () {
          ready = true;
        });

        function tick() {
          if (ready && video.duration) {
            var section = sectionRef.current;
            if (section) {
              var rect = section.getBoundingClientRect();
              var total = section.offsetHeight - window.innerHeight;
              if (total > 0) {
                var p = Math.max(0, Math.min(1, -rect.top / total));
                var targetTime = p * video.duration;
                if (Math.abs(video.currentTime - targetTime) > 0.05) {
                  video.currentTime = targetTime;
                }
              }
            }
          }
          rafId = requestAnimationFrame(tick);
        }
        rafId = requestAnimationFrame(tick);

        return function () {
          if (rafId) cancelAnimationFrame(rafId);
        };
      }, []);
      return /*#__PURE__*/React.createElement("section", {
        ref: sectionRef,
        id: "contact",
        style: {
          height: '500vh',
          position: 'relative',
          background: '#f0f1fa',
          zIndex: 1
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }
      }, /*#__PURE__*/React.createElement("video", {
        ref: videoRef,
        src: './scroll-video.mp4',
        muted: true,
        playsInline: true,
        preload: 'auto',
        style: {
          maxWidth: '60%',
          maxHeight: '70vh'
        }
      })));
    }

    // ========== PORTFOLIO — 3D MAGIC CARPET ==========
    function PortfolioSection() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      var sectionRef = useRef(null);
      var rect1Ref = useRef(null);
      var rect2Ref = useRef(null);
      var vid1Ref = useRef(null);
      var vid2Ref = useRef(null);
      var play1BtnRef = useRef(null);
      var play2BtnRef = useRef(null);
      var cur1 = useRef({ x: -65, y: -35, s: 0.08, op: 0 });
      var cur2 = useRef({ x: 65, y: 35, s: 0.08, op: 0 });
      var rafRef = useRef(null);
      useEffect(function () {
        var section = sectionRef.current;
        var r1 = rect1Ref.current;
        var r2 = rect2Ref.current;
        var v1 = vid1Ref.current;
        var v2 = vid2Ref.current;
        if (!section || !r1 || !r2) return;
        var c1 = cur1.current;
        var c2 = cur2.current;
        var LERP = 0.09;
        function lerp(a, b, t) { return a + (b - a) * t; }

        var d1 = { ix: -65, iy: -35, ex: 75, ey: -8 };
        var d2 = { ix: 65, iy: 35, ex: -75, ey: 8 };

        function getTargets(p, d) {
          if (p < 0.22) {
            var t = p / 0.22;
            var e = 1 - Math.pow(1 - t, 3);
            return {
              x: d.ix * (1 - e), y: d.iy * (1 - e),
              s: 0.08 + 0.92 * e,
              op: e
            };
          }
          if (p < 0.55) {
            return { x: 0, y: 0, s: 1.0, op: 1 };
          }
          if (p < 0.72) {
            return { x: 0, y: 0, s: 1.0, op: 1 };
          }
          var t3 = (p - 0.72) / 0.28;
          var e3 = t3 * t3;
          return {
            x: d.ex * e3, y: d.ey * e3, s: 1.0 - 0.15 * e3,
            op: 1 - e3
          };
        }

        function applyRect(el, bendEl, cur) {
          el.style.transform = 'translate(' + cur.x + 'vw, ' + cur.y + 'vh) scale(' + cur.s + ')';
          el.style.opacity = cur.op;
        }

        function lerpAll(c, tgt) {
          c.x = lerp(c.x, tgt.x, LERP);
          c.y = lerp(c.y, tgt.y, LERP);
          c.s = lerp(c.s, tgt.s, LERP);
          c.op = lerp(c.op, tgt.op, LERP);
        }

        // Visibility-gated animation — stop rAF when section is off-screen
        var portVisible = false;
        var portObs = new IntersectionObserver(function (entries) {
          portVisible = entries[0].isIntersecting;
          if (portVisible && !rafRef.current) animate();
        }, { rootMargin: '200px', threshold: 0 });
        portObs.observe(section);

        // Cache sectionH (only changes on resize)
        var cachedSectionH = section.offsetHeight;
        var cachedVh = window.innerHeight;
        var resizeHandler = function () {
          cachedSectionH = section.offsetHeight;
          cachedVh = window.innerHeight;
        };
        window.addEventListener('resize', resizeHandler);

        function animate() {
          if (!portVisible) {
            rafRef.current = null;
            if (v1 && !v1.paused) v1.pause();
            if (v2 && !v2.paused) v2.pause();
            if (!isMob) {
              var _pb1 = play1BtnRef.current;
              var _pb2 = play2BtnRef.current;
              if (_pb1) _pb1.style.opacity = '1';
              if (_pb2) _pb2.style.opacity = '1';
            }
            return;
          }
          var bounds = section.getBoundingClientRect();
          var raw = (cachedVh - bounds.top) / (cachedSectionH + cachedVh);
          var pFull = Math.max(0, Math.min(1, (raw - 0.05) / 0.9));

          var p1 = Math.max(0, Math.min(1, pFull / 0.52));
          lerpAll(c1, getTargets(p1, d1));
          applyRect(r1, null, c1);

          var p2 = Math.max(0, Math.min(1, (pFull - 0.48) / 0.52));
          lerpAll(c2, getTargets(p2, d2));
          applyRect(r2, null, c2);

          // Video: show when card visible
          if (v1) {
            if (c1.op > 0.3) {
              if (isMob && v1.paused) v1.play().catch(function(){});
            } else {
              if (!v1.paused) v1.pause();
              if (!isMob) { var pb1 = play1BtnRef.current; if (pb1) pb1.style.opacity = '1'; }
            }
          }
          if (v2) {
            if (c2.op > 0.3) {
              if (isMob && v2.paused) v2.play().catch(function(){});
            } else {
              if (!v2.paused) v2.pause();
              if (!isMob) { var pb2 = play2BtnRef.current; if (pb2) pb2.style.opacity = '1'; }
            }
          }

          rafRef.current = requestAnimationFrame(animate);
        }
        rafRef.current = requestAnimationFrame(animate);
        return function () {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
          portObs.disconnect();
          window.removeEventListener('resize', resizeHandler);
        };
      }, [isMob]);
      function togglePlay(vidRef, btnRef) {
        var v = vidRef.current;
        var btn = btnRef.current;
        if (!v) return;
        if (v.paused) {
          v.play().catch(function () { });
          if (btn) btn.style.opacity = '0';
        } else {
          v.pause();
          if (btn) btn.style.opacity = '1';
        }
      }
      var rectW = isMob ? '92vw' : '70vw';
      var rectH = isMob ? '55vh' : '72vh';
      var rectR = isMob ? '20px' : '28px';
      var rectStyle = {
        position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, margin: 'auto',
        width: rectW, height: rectH, borderRadius: rectR,
        background: '#1a1a1a', willChange: 'transform, opacity',
        boxShadow: '0 40px 80px rgba(0,0,0,0.5)', overflow: 'hidden',
        opacity: 0
      };
      var vidStyle = { position: 'absolute', inset: 0, width: '100%', height: '100%', objectFit: 'cover', borderRadius: 'inherit', opacity: 1 };
      var overlayStyle = {
        position: 'absolute', bottom: 0, left: 0, right: 0, zIndex: 3,
        background: 'linear-gradient(to top, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 60%, transparent 100%)',
        padding: isMob ? '40px 20px 24px' : '60px 40px 32px',
        borderRadius: '0 0 ' + rectR + ' ' + rectR
      };
      var titleStyle = {
        fontSize: isMob ? '40px' : '60px', fontFamily: 'Archivo, sans-serif',
        fontWeight: 700, color: '#fff', margin: 0, lineHeight: 1.1
      };
      var descStyle = {
        fontSize: isMob ? '22px' : '28px', fontFamily: 'Archivo, sans-serif',
        fontWeight: 400, color: 'rgba(255,255,255,0.6)', margin: 0,
        marginTop: isMob ? '8px' : '12px', lineHeight: 1.4
      };
      var playBtnStyle = {
        position: 'absolute', top: '50%', left: '50%', transform: 'translate(-50%, -50%)',
        width: isMob ? '60px' : '80px', height: isMob ? '60px' : '80px', borderRadius: '50%',
        background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center',
        cursor: 'pointer', zIndex: 5, transition: 'opacity 0.3s ease',
        backdropFilter: 'blur(6px)', WebkitBackdropFilter: 'blur(6px)',
        border: '2px solid rgba(255,255,255,0.25)'
      };
      var playTriStyle = {
        width: 0, height: 0,
        borderTop: (isMob ? '13px' : '17px') + ' solid transparent',
        borderBottom: (isMob ? '13px' : '17px') + ' solid transparent',
        borderLeft: (isMob ? '20px' : '26px') + ' solid #fff',
        marginLeft: '4px'
      };
      return /*#__PURE__*/React.createElement("section", {
        ref: sectionRef,
        style: { position: 'relative', height: isMob ? '500vh' : '600vh', background: 'inherit', zIndex: 2, marginTop: '-5px', paddingTop: '5px' }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'sticky', top: 0, height: '100vh',
          display: 'flex', alignItems: 'center', justifyContent: 'center',
          overflow: 'hidden'
        }
      },
      /*#__PURE__*/React.createElement("div", { ref: rect1Ref, style: Object.assign({}, rectStyle, isMob ? {} : { cursor: 'pointer' }), onClick: isMob ? undefined : function () { togglePlay(vid1Ref, play1BtnRef); } },
        /*#__PURE__*/React.createElement("video", { ref: vid1Ref, src: './portfolio-reel.mp4', muted: true, loop: true, playsInline: true, preload: 'auto', style: vidStyle }),
        !isMob && /*#__PURE__*/React.createElement("div", { ref: play1BtnRef, style: playBtnStyle },
          /*#__PURE__*/React.createElement("div", { style: playTriStyle })
        ),
        /*#__PURE__*/React.createElement("div", { style: overlayStyle },
          /*#__PURE__*/React.createElement("h3", { style: titleStyle }, "POP IN THE CITY"),
          /*#__PURE__*/React.createElement("p", { style: descStyle }, "\u0421\u0430\u0439\u0442 \u0434\u043B\u044F \u043D\u0430\u0434\u0443\u0432\u043D\u044B\u0445 \u0430\u0442\u0442\u0440\u0430\u043A\u0446\u0438\u043E\u043D\u043E\u0432 \u0432 \u041D\u044C\u044E-\u0419\u043E\u0440\u043A\u0435")
      )
      ),
      /*#__PURE__*/React.createElement("div", { ref: rect2Ref, style: Object.assign({}, rectStyle, isMob ? {} : { cursor: 'pointer' }), onClick: isMob ? undefined : function () { togglePlay(vid2Ref, play2BtnRef); } },
        /*#__PURE__*/React.createElement("video", { ref: vid2Ref, src: './portfolio-reel-2.mp4', muted: true, loop: true, playsInline: true, preload: 'auto', style: vidStyle }),
        !isMob && /*#__PURE__*/React.createElement("div", { ref: play2BtnRef, style: playBtnStyle },
          /*#__PURE__*/React.createElement("div", { style: playTriStyle })
        ),
        /*#__PURE__*/React.createElement("div", { style: {
          position: 'absolute', top: 0, left: 0, right: 0, zIndex: 3,
          background: 'linear-gradient(to bottom, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 60%, transparent 100%)',
          padding: isMob ? '24px 20px 40px' : '32px 40px 60px',
          borderRadius: rectR + ' ' + rectR + ' 0 0'
        } },
          /*#__PURE__*/React.createElement("h3", { style: titleStyle }, "CLAYNOSAURZ"),
          /*#__PURE__*/React.createElement("p", { style: descStyle }, "\u041C\u0438\u043D\u0438-\u0444\u0438\u043B\u044C\u043C\u044B \u0441 3D \u043C\u0438\u0440\u043E\u0432\u043E\u0433\u043E \u0443\u0440\u043E\u0432\u043D\u044F")
      )
      )));
    }

    // ========== SPLINE 3D SECTION ==========
    function Spotlight(props) {
      var className = props.className || '';
      var fill = props.fill || 'white';
      return React.createElement('svg', {
        className: 'animate-spotlight pointer-events-none absolute z-[1] h-[169%] w-[138%] lg:w-[84%] opacity-0 ' + className,
        xmlns: 'http://www.w3.org/2000/svg',
        viewBox: '0 0 3787 2842',
        fill: 'none'
      }, React.createElement('g', {
        filter: 'url(#spotlight-filter)'
      }, React.createElement('ellipse', {
        cx: '1924.71',
        cy: '273.501',
        rx: '1924.71',
        ry: '273.501',
        transform: 'matrix(-0.822377 -0.568943 -0.568943 0.822377 3631.88 2291.09)',
        fill: fill,
        fillOpacity: '0.21'
      })), React.createElement('defs', null, React.createElement('filter', {
        id: 'spotlight-filter',
        x: '0.860352',
        y: '0.838989',
        width: '3785.16',
        height: '2840.26',
        filterUnits: 'userSpaceOnUse',
        colorInterpolationFilters: 'sRGB'
      }, React.createElement('feFlood', {
        floodOpacity: '0',
        result: 'BackgroundImageFix'
      }), React.createElement('feBlend', {
        mode: 'normal',
        in: 'SourceGraphic',
        in2: 'BackgroundImageFix',
        result: 'shape'
      }), React.createElement('feGaussianBlur', {
        stdDeviation: '151',
        result: 'effect1_foregroundBlur'
      }))));
    }
    function SplineSection() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      var sectionRef = useRef(null);
      var cursorBtnRef = useRef(null);
      var splineContainerRef = useRef(null);

      useEffect(function () {
        var el = sectionRef.current;
        var container = splineContainerRef.current;
        if (!el || !container) return;

        var splineLoaded = false;

        var obs = new IntersectionObserver(function (entries) {
          if (entries[0].isIntersecting && !splineLoaded) {
            splineLoaded = true;
            // НЕ ставим _splineVisible = true здесь!
            // Three.js продолжает работать

            var doLoad = function () {
              var viewer = document.createElement('spline-viewer');
              viewer.setAttribute('url', 'https://prod.spline.design/kZDDjO5HuC9GJUM2/scene.splinecode');
              viewer.style.cssText = [
                'width:100%',
                'height:100%',
                'position:absolute',
                'inset:0',
                'opacity:0',
                'transition:opacity 0.8s ease'
              ].join(';');

              container.appendChild(viewer);

              // Wait for Spline to render first frame
              // spline-viewer has no ready event, so check for canvas in shadow DOM
              var attempts = 0;
              var checkReady = function () {
                attempts++;
                var shadow = viewer.shadowRoot;
                var canvas = shadow && shadow.querySelector('canvas');
                if ((canvas && canvas.width > 0) || attempts > 25) {
                  // 25 * 200ms = 5 sec max wait
                  viewer.style.opacity = '1';
                  // Stop Three.js AFTER robot appears
                  setTimeout(function () {
                    _splineVisible = true;
                  }, 800); // after opacity transition completes
                } else {
                  setTimeout(checkReady, 200);
                }
              };
              setTimeout(checkReady, 1000); // start checking after 1 sec
            };

            if ('requestIdleCallback' in window) {
              requestIdleCallback(doLoad, { timeout: 3000 });
            } else {
              setTimeout(doLoad, 100);
            }
          }

          // Bidirectional observer for pause/resume
          if (!entries[0].isIntersecting && splineLoaded) {
            _splineVisible = false;
            if (_onSplineChange) _onSplineChange(); // resume Three.js
          }
        }, { rootMargin: '300px' });

        obs.observe(el);

        return function () {
          obs.disconnect();
        };
      }, []);

      // Cursor-following button
      useEffect(function () {
        if (isMob) return;
        var el = sectionRef.current;
        var btn = cursorBtnRef.current;
        if (!el || !btn) return;
        var initX = el.offsetWidth / 2;
        var initY = el.offsetHeight * 0.58;
        var mx = initX, my = initY, cx = initX, cy = initY;
        var inside = false;
        var rafId = null;

        function onEnter() {
          inside = true;
          btn.style.opacity = '1';
          btn.style.transform = 'translate(-50%,-50%) scale(1)';
          if (!rafId) tick();
        }
        function onLeave() {
          inside = false;
          btn.style.opacity = '0';
          btn.style.transform = 'translate(-50%,-50%) scale(0.5)';
        }
        function onMove(e) {
          var r = el.getBoundingClientRect();
          mx = e.clientX - r.left;
          my = e.clientY - r.top;
        }
        function tick() {
          cx = mx;
          cy = my;
          btn.style.left = cx + 'px';
          btn.style.top = cy + 'px';
          rafId = requestAnimationFrame(tick);
          if (!inside && Math.abs(mx - cx) < 0.5 && Math.abs(my - cy) < 0.5) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }
        }

        el.addEventListener('mouseenter', onEnter);
        el.addEventListener('mouseleave', onLeave);
        el.addEventListener('mousemove', onMove);
        return function () {
          el.removeEventListener('mouseenter', onEnter);
          el.removeEventListener('mouseleave', onLeave);
          el.removeEventListener('mousemove', onMove);
          if (rafId) cancelAnimationFrame(rafId);
        };
      }, [isMob]);

      return /*#__PURE__*/React.createElement("section", {
        ref: sectionRef,
        id: "spline-scene",
        className: "spline-wrap",
        style: {
          position: 'relative',
          width: '100%',
          height: '100vh',
          background: 'inherit',
          overflow: 'hidden',
          contentVisibility: 'auto',
          containIntrinsicSize: '0 100vh'
        }
      },
        // Container for Spline viewer
        React.createElement('div', {
          ref: splineContainerRef,
          style: {
            position: 'absolute',
            inset: 0,
            width: '100%',
            height: '100%',
            zIndex: 0
          }
        }),
        // Solid bar — guarantees logo is hidden (mobile only)
        isMob && React.createElement('div', {
          style: {
            position: 'absolute',
            bottom: 0,
            left: 0,
            width: '100%',
            height: '50px',
            background: '#0a0a12',
            zIndex: 11
          }
        }),
        // Gradient — smooth transition above the solid bar (mobile only)
        isMob && React.createElement('div', {
          style: {
            position: 'absolute',
            bottom: '50px',
            left: 0,
            width: '100%',
            height: '150px',
            background: 'linear-gradient(to bottom, rgba(10,10,18,0) 0%, rgba(10,10,18,0.15) 20%, rgba(10,10,18,0.4) 40%, rgba(10,10,18,0.7) 60%, rgba(10,10,18,0.9) 80%, rgba(10,10,18,1) 100%)',
            zIndex: 11
          }
        }),

        /* Outline Reveal Text - LET'S WORK */
        React.createElement('div', {
          className: 'lets-work-outline'
        },
          React.createElement('div', {
            style: {
              fontFamily: "'Unbounded', 'Archivo', sans-serif",
              fontWeight: isMob ? 600 : 800,
              fontSize: isMob ? 'clamp(50px, 15vw, 100px)' : 'clamp(120px, 13vw, 200px)',
              lineHeight: 1.1,
              letterSpacing: '-0.02em',
              textAlign: 'center',
              userSelect: 'none',
              whiteSpace: 'pre-line',
              color: 'transparent',
              WebkitTextFillColor: 'transparent',
              WebkitTextStroke: '3px #1a2ffb',
              animation: 'strokeColor 4s ease-in-out infinite'
            }
          }, isMob ? "LET'S\nWORK" : "LET'S WORK")
        ),

        !isMob && /*#__PURE__*/React.createElement("div", {
          style: {
            position: 'absolute',
            bottom: '7%',
            left: '7%',
            zIndex: 4
          }
        }, /*#__PURE__*/React.createElement("a", {
          href: "https://t.me/ceoXseo",
          target: "_blank",
          rel: "noopener noreferrer",
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: '12px',
            height: '57.6px',
            paddingLeft: '29.25px',
            paddingRight: '29.25px',
            background: 'rgb(43, 46, 58)',
            borderRadius: '106px',
            color: '#1a2ffb',
            fontFamily: 'Archivo, sans-serif',
            fontSize: '18px',
            fontWeight: 500,
            textTransform: 'uppercase',
            textDecoration: 'none',
            transition: 'background 0.3s'
          }
        }, "Telegram")),

        !isMob && /*#__PURE__*/React.createElement("div", {
          style: {
            position: 'absolute',
            bottom: '7%',
            right: '5%',
            zIndex: 4
          }
        }, /*#__PURE__*/React.createElement("a", {
          href: "mailto:hello@stun.agency",
          style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '57.6px',
            width: '132px',
            background: 'rgb(43, 46, 58)',
            borderRadius: '106px',
            fontFamily: 'Archivo, sans-serif',
            fontSize: '18px',
            fontWeight: 500,
            textTransform: 'uppercase',
            textDecoration: 'none',
            transition: 'background 0.3s'
          }
        }, /*#__PURE__*/React.createElement("span", {
          style: {
            background: 'linear-gradient(90deg, #4285F4, #EA4335, #FBBC05, #34A853)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent'
          }
        }, "Email"))),

        !isMob && /*#__PURE__*/React.createElement("a", {
          ref: cursorBtnRef,
          href: "https://t.me/ceoXseo",
          target: "_blank",
          rel: "noopener noreferrer",
          style: {
            position: 'absolute',
            left: 0,
            top: 0,
            opacity: 0,
            transform: 'translate(-50%,-50%) scale(0.5)',
            width: '120px',
            height: '120px',
            borderRadius: '50%',
            background: '#1a2ffb',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            color: '#fff',
            fontFamily: 'Archivo, sans-serif',
            fontSize: '14px',
            fontWeight: 600,
            textTransform: 'uppercase',
            letterSpacing: '0.05em',
            textDecoration: 'none',
            zIndex: 20,
            pointerEvents: 'auto',
            transition: 'opacity 0.3s ease, transform 0.3s ease',
            boxShadow: '0 0 30px rgba(26,47,251,0.4)'
          }
        }, /*#__PURE__*/React.createElement("svg", {
          width: "44", height: "44", viewBox: "0 0 24 24", fill: "#fff", stroke: "none"
        },
          /*#__PURE__*/React.createElement("path", { d: "M5 2h14a3 3 0 0 1 3 3v8a3 3 0 0 1-3 3H8l-4 4V5a3 3 0 0 1 3-3z" })
        ))

      );
    }


    function App() {
      var bp = useBreakpoint();
      var isMob = bp === 'mobile';
      const [phase, setPhase] = useState('loading'); // 'loading' → 'ready'
      const revealRef = useReveal();
      const heroTextRef = useRef(null);
      const heroRectRef = useRef(null);
      const heroCrosshairsRef = useRef(null);
      const heroScrollRef = useRef(null);
      useSmoothScroll();
      useHeroParallax(heroTextRef, heroRectRef, heroCrosshairsRef, heroScrollRef);
      return /*#__PURE__*/React.createElement("div", {
        ref: revealRef
      }, phase === 'loading' && /*#__PURE__*/React.createElement(LoadingBar, {
        onLoaded: function () {
          setPhase('ready');
        }
      }), phase === 'loading' ? null : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CustomCursor, null), /*#__PURE__*/React.createElement(Navigation, null), /*#__PURE__*/React.createElement("section", {
        className: "flex flex-col items-center bg-[#f0f1fa] relative",
        style: {
          paddingBottom: isMob ? '8px' : '64px',
          justifyContent: isMob ? 'flex-start' : 'flex-end',
          minHeight: isMob ? 'auto' : '100vh'
        }
      }, /*#__PURE__*/React.createElement("div", {
        style: {
          display: 'grid',
          gridTemplateColumns: isMob ? '1fr' : 'repeat(12, minmax(0, 1fr))',
          columnGap: isMob ? '0' : '40px',
          width: '100%',
          paddingLeft: '5%',
          paddingRight: '5%',
          paddingTop: isMob ? '80px' : '38px',
          paddingBottom: isMob ? '20px' : '30px',
          position: isMob ? 'relative' : 'absolute',
          top: isMob ? 'auto' : 0,
          left: isMob ? 'auto' : 0,
          right: isMob ? 'auto' : 0,
          zIndex: 3
        }
      }, /*#__PURE__*/React.createElement("h1", {
        style: {
          fontSize: isMob ? 'clamp(20px, 5.5vw, 30px)' : 'clamp(32px, 3.2vw, 48px)',
          gridColumnStart: isMob ? 1 : 4,
          gridColumnEnd: isMob ? -1 : 'span 6',
          fontFamily: 'Archivo, sans-serif',
          fontWeight: 400,
          lineHeight: 1.25,
          color: '#0a0a12',
          margin: 0,
          height: 'fit-content'
        }
      }, "\u041C\u044B \u043F\u043E\u043C\u043E\u0433\u0430\u0435\u043C \u0431\u0440\u0435\u043D\u0434\u0430\u043C \u0441\u043E\u0437\u0434\u0430\u0432\u0430\u0442\u044C", /*#__PURE__*/React.createElement("br", null), "\u0446\u0438\u0444\u0440\u043E\u0432\u043E\u0439 \u043E\u043F\u044B\u0442, \u043A\u043E\u0442\u043E\u0440\u044B\u0439", /*#__PURE__*/React.createElement("br", null), "\u0437\u0430\u043F\u043E\u043C\u0438\u043D\u0430\u0435\u0442\u0441\u044F \u043D\u0430\u0432\u0441\u0435\u0433\u0434\u0430")), /*#__PURE__*/React.createElement("div", {
        style: {
          position: 'relative',
          width: isMob ? '96%' : '90%',
          height: isMob ? '62vh' : '69vh'
        }
      }, /*#__PURE__*/React.createElement("div", {
        ref: heroRectRef,
        style: {
          width: '100%',
          height: '100%',
          borderRadius: '20px',
          overflow: 'hidden',
          position: 'relative',
          zIndex: 2,
          willChange: 'transform'
        }
      }, /*#__PURE__*/React.createElement(StellatedScene, null))), /*#__PURE__*/React.createElement("div", {
        ref: heroCrosshairsRef,
        style: {
          position: isMob ? 'relative' : 'absolute',
          bottom: isMob ? 'auto' : '18px',
          left: isMob ? 'auto' : '5%',
          right: isMob ? 'auto' : '5%',
          width: isMob ? '96%' : 'auto',
          marginTop: isMob ? '14px' : '0',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          pointerEvents: 'none'
        }
      }, /*#__PURE__*/React.createElement("svg", {
        width: isMob ? '14' : '20',
        height: isMob ? '14' : '20',
        viewBox: "0 0 20 20",
        fill: "none"
      }, /*#__PURE__*/React.createElement("line", {
        x1: "10",
        y1: "0",
        x2: "10",
        y2: "20",
        stroke: "#0a0a12",
        strokeWidth: isMob ? '2.4' : '2.25'
      }), /*#__PURE__*/React.createElement("line", {
        x1: "0",
        y1: "10",
        x2: "20",
        y2: "10",
        stroke: "#0a0a12",
        strokeWidth: isMob ? '2.4' : '2.25'
      })), !isMob && /*#__PURE__*/React.createElement("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none"
      }, /*#__PURE__*/React.createElement("line", {
        x1: "10",
        y1: "0",
        x2: "10",
        y2: "20",
        stroke: "#0a0a12",
        strokeWidth: "2.25"
      }), /*#__PURE__*/React.createElement("line", {
        x1: "0",
        y1: "10",
        x2: "20",
        y2: "10",
        stroke: "#0a0a12",
        strokeWidth: "2.25"
      })), /*#__PURE__*/React.createElement("span", {
        ref: heroScrollRef,
        style: {
          fontSize: isMob ? '13px' : '16px',
          fontWeight: isMob ? 525 : 578,
          textTransform: 'uppercase',
          fontFamily: 'Archivo, sans-serif',
          letterSpacing: '0.05em',
          color: '#0a0a12',
          display: 'inline-block',
          transform: 'scaleY(1.15)',
          transformOrigin: 'bottom center'
        }
      }, "Scroll to explore"), !isMob && /*#__PURE__*/React.createElement("svg", {
        width: "20",
        height: "20",
        viewBox: "0 0 20 20",
        fill: "none"
      }, /*#__PURE__*/React.createElement("line", {
        x1: "10",
        y1: "0",
        x2: "10",
        y2: "20",
        stroke: "#0a0a12",
        strokeWidth: "2.25"
      }), /*#__PURE__*/React.createElement("line", {
        x1: "0",
        y1: "10",
        x2: "20",
        y2: "10",
        stroke: "#0a0a12",
        strokeWidth: "2.25"
      })), /*#__PURE__*/React.createElement("svg", {
        width: isMob ? '14' : '20',
        height: isMob ? '14' : '20',
        viewBox: "0 0 20 20",
        fill: "none"
      }, /*#__PURE__*/React.createElement("line", {
        x1: "10",
        y1: "0",
        x2: "10",
        y2: "20",
        stroke: "#0a0a12",
        strokeWidth: isMob ? '2.4' : '2.25'
      }), /*#__PURE__*/React.createElement("line", {
        x1: "0",
        y1: "10",
        x2: "20",
        y2: "10",
        stroke: "#0a0a12",
        strokeWidth: isMob ? '2.4' : '2.25'
      })))),

        /*#__PURE__*/React.createElement(CardServices, null), /*#__PURE__*/React.createElement("div", { style: { background: '#0a0a0a' } }, /*#__PURE__*/React.createElement(AboutSection, null), /*#__PURE__*/React.createElement(PortfolioSection, null), /*#__PURE__*/React.createElement(SplineSection, null))));
    }
    ReactDOM.createRoot(document.getElementById('root')).render(/*#__PURE__*/React.createElement(App, null));
  </script>
  <script type="module" src="https://unpkg.com/@splinetool/viewer@1.9.82/build/spline-viewer.js"></script>

</body>

</html>